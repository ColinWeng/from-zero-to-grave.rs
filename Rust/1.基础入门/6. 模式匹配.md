[TOC]

​	模式匹配，这个词，对于非函数语言编程来说，真的还蛮少听到，因为它经常出现在函数式编程里，用于为复杂的类型系统提供一个轻松的解构能力。

## `match` 和 `if let`

​	模式匹配最常用的就是 `match` 和 `if let`。

### `match` 匹配

```rust
// `match` 的通用形式
// `match` 的匹配必须穷尽所有情况。
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
}
```

#### 使用 match 表达式赋值

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    // 	还有一点很重要，`match` 本身也是一个表达式，因此可以用它来赋值：
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        // 因为这里匹配到 `_` 分支，所以将 `"::1"` 赋值给了 `ip_str`。
        _ => "::1",
    };

    println!("{}", ip_str);
}
```

#### 模式绑定

```rust
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            // 	模式匹配的另外一个重要功能是从模式中取出绑定的值。
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, _) => {
                println!("change color into '(r:{}, g:{}, b:0)', 'b' has been ignored",
                    r, g,
                );
            }
        }
    }
}
```

#### `_` 通配符

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    //`_` 将会匹配所有遗漏的值。
    //`()` 表示返回**单元类型**与所有分支返回值的类型相同，
    //所以当匹配到 `_` 后，什么也不会发生。
    _ => (),
}
```

### `if let` 匹配

```rust
// 只有一个模式的值需要被处理，其它值直接忽略的场景，完全可以用 `if let` 的方式来实现
if let Some(3) = v {
    println!("three");
}
```

​	只要记住一点就好：**当你只要匹配一个条件，且忽略其他条件时就用 `if let` ，否则都用 `match`**。

### matches!宏

​	Rust 标准库中提供了一个非常实用的宏：`matches!`，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 `true` or `false`。

```rust
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```

## 变量遮蔽

​	无论是 `match` 还是 `if let`，这里都是一个新的代码块，而且这里的绑定相当于新变量，如果你使用同名变量，会发生变量遮蔽：

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}",age);
   // 左边的遮蔽了右边的
   if let Some(age) = age {						
       println!("匹配出来的age是{}",age);
   }

   println!("在匹配后，age是{:?}",age);
}
```

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}",age);
   match age {
       Some(age) =>  println!("匹配出来的age是{}",age),
       _ => ()
   }
   println!("在匹配后，age是{:?}",age);
}
```

​	需要注意的是，**`match` 中的变量遮蔽其实不是那么的容易看出**，因此要小心！其实这里最好不要使用同名，避免难以理解。

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}", age);
   match age {
       Some(x) =>  println!("匹配出来的age是{}", x),
       _ => ()
   }
   println!("在匹配后，age是{:?}", age);
}
```

## 解构 `Option`

简单解释就是：**一个变量要么有值：`Some(T)`, 要么为空：`None`**。

```rust
enum Option<T> {
    None,
    Some(T),
}
```

```rust
// 编写一个函数，它获取一个 `Option<i32>`，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 `None` 值：
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

## 模式适用场景

​	模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 `match` 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：

- 字面值
- 解构的数组、枚举、结构体或者元组
- 变量
- 通配符
- 占位符

### 可能用到模式的地方

#### match 分支

 ```rust
  match VALUE {
      PATTERN => EXPRESSION,
      PATTERN => EXPRESSION,
      _ => EXPRESSION,
  }
 ```

#### if let 分支

 ```rust
  if let PATTERN = SOME_VALUE {
  
  }
 ```

#### while let 条件循环

 ```rust
  // Vec是动态数组
  let mut stack = Vec::new();
  
  // 向数组尾部插入元素
  stack.push(1);
  stack.push(2);
  stack.push(3);
  
  // stack.pop从数组尾部弹出元素
  // 一个与 `if let` 类似的结构是 `while let` 条件循环，它允许只要模式匹配就一直进行 `while` 循环。
  while let Some(top) = stack.pop() {
      println!("{}", top);
  }
 ```

#### for 循环

 ```rust
  let v = vec!['a', 'b', 'c'];
  
  // 这里使用 `enumerate` 方法产生一个迭代器，该迭代器每次迭代会返回一个 `(索引，值)` 形式的元组，然后用 `(index,value)` 来匹配。
  for (index, value) in v.iter().enumerate() {
      println!("{} is at index {}", value, index);
  }
 ```

#### let  语句

```rust
// 该语句我们已经用了无数次了，它也是一种模式匹配
let PATTERN = EXPRESSION;
```

```rust
// `x` 也是一种模式绑定，代表将**匹配的值绑定到变量 x 上**。因此，在 Rust 中，**变量名也是一种模式**，只不过它比较朴素很不起眼罢了。
let x = 5;
```

```rust
// 将一个元组与模式进行匹配（**模式和值的类型必需相同！**），然后把 `1, 2, 3` 分别绑定到 `x, y, z` 上。
let (x, y, z) = (1, 2, 3);
```

#### 函数参数

```rust
// 函数参数也是模式
//  `x` 就是一个模式
fn foo(x: i32) {
    // 代码
}
```

```rust
// 还可以在参数中匹配元组：
// `&(3, 5)` 会匹配模式 `&(x, y)`，因此 `x` 得到了 `3`，`y` 得到了 `5`。
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

#### let 和 if let

```rust
let Some(x) = some_option_value; // 编译器会报错
```

​	因为右边的值可能不为 `Some`，而是 `None`，这种时候就不能进行匹配，也就是上面的代码遗漏了 `None` 的匹配。

​	类似 `let` , `for`和`match` 都必须要求完全覆盖匹配，才能通过编译( 不可驳模式匹配 )。

​        但是对于 `if let`，就可以这样使用：

```rust
// 	因为 `if let` 允许匹配一种模式，而忽略其余的模式( 可驳模式匹配 )。
if let Some(x) = some_option_value {
    println!("{}", x);
}
```

#### let else (Rust 1.65 新增)

​	使用 `let-else` 匹配，即可使 `let` 变为可驳模式。它可以使用 `else` 分支来处理模式不匹配的情况，但是 `else` 分支中必须用发散的代码块处理（例如：`break`、`return`、`panic`）。请看下面的代码：

```rust
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    // error: `else` clause of `let...else` does not diverge
    // let Ok(count) = u64::from_str(count_str) else { 0 };
    (count, item)
}

fn main() {
    assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
}
```

​	与 `match` 和 `if let` 相比，`let-else` 的一个显著特点在于其解包成功时所创建的变量具有更广的作用域。在 `let-else` 语句中，成功匹配后的变量不再仅限于特定分支内使用：

```rust
// if let
// `if let` 写法里的 `x` 只能在 `if` 分支内使用
if let Some(x) = some_option_value {
    println!("{}", x);
}

// let-else
// 而 `let-else` 写法里的 `x` 则可以在 `let` 之外使用。
let Some(x) = some_option_value else { return; }
println!("{}", x);
```

## 全模式列表

### 匹配字面值

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

### 匹配命名变量

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y), // y 是新变量，遮蔽了外面的y
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}
```

```bash
Matched, y = 5
at the end: x = Some(5), y = 10
```

### 单分支多模式

```rust
let x = 1;

match x {
    // 可以使用 `|` 语法匹配多个模式，它代表 **或**的意思
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

### 通过序列 `..=` 匹配值的范围

```rust
let x = 5;

match x {
    // `..=` 语法允许你匹配一个闭区间序列内的值。
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

### 解构并分解值

#### 解构结构体

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

  	// 变量 `a` 和 `b` 来匹配结构体 `p` 中的 `x` 和 `y` 字段
    // 这个例子展示了 模式中的变量名不必与结构体中的字段名一致
    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        // 展示了固定某个字段的匹配方式
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```

#### 解构枚举

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x,
                y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
    }
}
```

#### 解构嵌套的结构体和枚举

```rust
enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}
```

#### 解构结构体和元组

```rust
struct Point {
     x: i32,
     y: i32,
 }

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
```

#### 解构数组

```rust
let arr: [u16; 2] = [114, 514];
let [x, y] = arr;

assert_eq!(x, 114);
assert_eq!(y, 514);
```

```rust
let arr: &[u16] = &[114, 514];

if let [x, ..] = arr {
    assert_eq!(x, &114);
}

if let &[.., y] = arr {
    assert_eq!(y, 514);
}

let arr: &[u16] = &[];

assert!(matches!(arr, [..]));
assert!(!matches!(arr, [x, ..]));
```

### 忽略模式中的值

#### 使用 `_` 忽略整个值

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```

```rust
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("setting is {:?}", setting_value);
```

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

#### 用 `..` 忽略剩余值

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        },
    }
}
```

### 匹配守卫提供的额外条件

```rust
let num = Some(4);

match num {
    // **匹配守卫**（*match guard*）是一个位于 `match` 分支模式之后的额外 `if` 条件
    // 它能为分支模式提供更进一步的匹配条件
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}
```

### `@` 绑定

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    // 	`@`（读作 at）运算符允许为一个字段绑定另外一个变量。
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
```

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 绑定新变量 `p`，同时对 `Point` 进行解构
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
```



> 参考资料：
>
> 1. https://course.rs/basic/match-pattern/intro.html
> 2. https://practice-zh.course.rs/pattern-match/intro.html