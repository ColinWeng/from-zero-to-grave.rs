[TOC]

## 类型推导与标注

​	Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 Rust 编译器可以根据变量值和上下文的使用方式来**自动推导**出变量的类型。

​	某些情况下，它也无法推导出变量类型，需要手动给予一个类型标注。

## 数值类型

### 整数类型

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | `i8`       | `u8`       |
| 16 位      | `i16`      | `u16`      |
| 32 位      | `i32`      | `u32`      |
| 64 位      | `i64`      | `u64`      |
| 128 位     | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |



| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

#### 整型溢出

​	当在 debug 模式编译时，Rust 会检查整型溢出，若存在，程序会在编译时 panic。

​	当在 release 模式构建时，Rust 不检查溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出的规则处理。比如在`u8` 的情况下，256 变 0,257 变 1。

​	要显示处理可能的溢出，可以使用标准库针对原始数字类型提供的方法：

* 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
* 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
* 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
* 使用 `saturating_*` 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，

### 浮点类型

```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

#### NaN

```rust
fn main() {
    // 对于数学上未定义的结果，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number) 来处理这些情况。
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

### 数字运算

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 求余
    let remainder = 43 % 5;
}
```

### 位运算

| 运算符  | 说明                                                   |
| ------- | ------------------------------------------------------ |
| & 位与  | 相同位置均为1时则为1，否则为0                          |
| \| 位或 | 相同位置只要有1时则为1，否则为0                        |
| ^ 异或  | 相同位置不相同则为1，相同则为0                         |
| ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0                 |
| << 左移 | 所有位向左移动指定位数，右位补0                        |
| >> 右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

### 序列（Range）

```rust
//  `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；
//  `1..=5`，生成从 1 到 5 的连续数字，包含 5
for i in 1..=5 {
    println!("{}",i);
}

// 序列只允许用于数字或字符类型，原因是：它们可以连续。
for i in 'a'..='z' {
    println!("{}",i);
}
```



### 有理数和复数

Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。

## 字符、布尔、单元类型

### 字符类型（char）

​	在 Rust 语言中这些都是字符，Rust 的字符不仅仅是 `ASCII`，所有的 `Unicode` 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。`Unicode` 值的范围从 `U+0000 ~ U+D7FF` 和 `U+E000 ~ U+10FFFF`。

​	由于 `Unicode` 都是 4 个字节编码，因此字符类型也是占用 4 个字节：

```rust
fn main() {
    let x = '中';
    println!("字符'中'占用了{}字节的内存大小", size_of_val(&x));
}
```

> Rust 的字符只能用 `''` 来表示， `""` 是留给字符串的。

### 布尔（bool）

```rust
fn main() {
    // 布尔值占用内存的大小为 `1` 个字节
    let t = true;
    let f: bool = false; // 使用类型标注,显式指定f的类型
    if f {
        println!("这是段毫无意义的代码");
    }
}
```

### 单元类型（unit）

​	单元类型就是 `()` 。 `main` 函数就返回这个单元类型 `()`，你不能说 `main` 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：`发散函数( diverging functions )`，顾名思义，无法收敛的函数。

## 语句与表达式

​	Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式会在求值后返回一个值
}
```

### 语句（statement）

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

​	以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。

### 表达式（expression）

```rust
fn main() {
    let y = {
        let x = 3;
      	// 表达式会进行求值，然后返回一个值。
        x + 1  
    };

    println!("The value of y is: {}", y);
}
```

​	上面使用一个语句块表达式将值赋给 `y` 变量。

​	最后，表达式如果不返回任何值，会隐式地返回一个 [`()`](https://course.rs/basic/base-type/char-bool.html#单元类型) 。

```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // 或者写成一行
    let z = if x % 2 == 1 { "odd" } else { "even" };
}
```

## 函数

```rust
fn add(i: i32, j: i32) -> i32 {
   i + j
}
```



![](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)

### 函数参数

```rust
fn main() {
    another_function(5, 6.1);
}

// Rust 是静态类型语言，因此需要你为每一个函数参数都标识出它的具体类型。
fn another_function(x: i32, y: f32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

### 函数返回

```rust
fn plus_five(x:i32) -> i32 {
  	// 使用 `return` 提前返回, 也可以使用表达式返回
    x + 5
}

fn main() {
    let x = plus_five(5);
    println!("The value of x is: {}", x);
}
```

#### Rust 中特殊返回类型

例如单元类型 `()`，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：

- 函数没有返回值，那么返回一个 `()`
- 通过 `;` 结尾的语句返回一个 `()`



当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverging functions )，特别的，这种语法往往用做会导致程序崩溃的函数：

```rust
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
```



> 参考资料：
>
> 1. https://course.rs/basic/base-type/index.html
> 2. https://practice-zh.course.rs/basic-types/intro.html
