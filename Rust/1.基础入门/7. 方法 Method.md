[TOC]

## 定义方法

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// Rust 使用 `impl` 来定义方法。
impl Rectangle {
    // `&self` 替代 `rectangle: &Rectangle`，
    // `&self` 其实是 `self: &Self` 的简写
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

### `self`、`&self` 和 `&mut self`

​	在一个 `impl` 块内，`Self` 指代被实现方法的结构体类型，`self` 指代此类型的实例，换句话说，`self` 指代的是 `Rectangle` 结构体实例。

​	需要注意的是，`self` 依然有所有权的概念：

- `self` 表示 `Rectangle` 的所有权转移到该方法中，这种形式用的较少
- `&self` 表示该方法对 `Rectangle` 的不可变借用
- `&mut self` 表示可变借用

### 方法名跟结构体字段相同

```rust
mod my {
    pub struct Rectangle {
        width: u32,
        pub height: u32,
    }
    
    // 在 Rust 中，允许方法名跟结构体的字段名相同：
    // 一般来说，方法跟字段同名，往往适用于实现 `getter` 访问器，例如:
    impl Rectangle {
        pub fn new(width: u32, height: u32) -> Self {
            Rectangle { width, height }
        }
        pub fn width(&self) -> u32 {
            return self.width;
        }
        pub fn height(&self) -> u32 {
            return self.height;
        }
    }
}

fn main() {
    // 因为是函数，所以不能用 `.` 的方式来调用，我们需要用 `::` 来调用
    let rect1 = my::Rectangle::new(30, 50);

    println!("{}", rect1.width()); // OK
    println!("{}", rect1.height()); // OK
    // println!("{}", rect1.width); // Error - the visibility of field defaults to private
    println!("{}", rect1.height); // OK
}
```

## 关联函数

​	这种定义在 `impl` 中且没有 `self` 的函数被称之为**关联函数**： 因为它没有 `self`，不能用 `f.read()` 的形式调用，因此它是一个函数而不是方法，它又在 `impl` 中，与结构体紧密关联，因此称为关联函数。

​	在之前的代码中，我们已经多次使用过关联函数，例如 `String::from`，用于创建一个动态字符串。

```rust
impl Rectangle {
    // Rust 中有一个约定俗成的规则，使用 `new` 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 `new` 作为关键字。
    fn new(w: u32, h: u32) -> Rectangle {
        Rectangle { width: w, height: h }
    }
}
```

​	因为是函数，所以不能用 `.` 的方式来调用，我们需要用 `::` 来调用，例如 `let sq = Rectangle::new(3, 3);`。这个方法位于结构体的命名空间中：`::` 语法用于关联函数和模块创建的命名空间。

## 多个 impl 定义

```rust
// Rust 允许我们为一个结构体定义多个 `impl` 块
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```


> 参考资料：
>
> 1. https://course.rs/basic/method.html
> 2. https://practice-zh.course.rs/method.html
