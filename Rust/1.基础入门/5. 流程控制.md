[TOC]

## `if else`

```rust
if condition == true {
    // A...
} else if condition == true{
    // B...
} else {
  	// C 
}
```



```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

以上代码有以下几点要注意：

- **`if` 语句块是表达式**，这里我们使用 `if` 表达式的返回值来给 `number` 进行赋值：`number` 的值是 `5`
- 用 `if` 来赋值时，要保证每个分支返回的类型一样，此处返回的 `5` 和 `6` 就是同一个类型，如果返回类型不一致就会报错

## `for` 循环

```rust
fn main() {
    for i in 1..=5 {
        println!("{}", i);
    }
}
```

​	以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 `for` 和 `in` 的联动，语义表达如下：

```rust
for 元素 in 集合 {
  // 使用元素干一些你懂我不懂的事情
}
```

​	注意，使用 `for` 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 `container` 的引用）。如果不使用引用的话，所有权会被转移（move）到 `for` 语句块中，后面就无法再使用这个集合了)：

```rust
for item in &container {
  // ...
}
```

​	如果想在循环中，**修改该元素**，可以使用 `mut` 关键字：

```rust
for item in &mut collection {
  // ...
}
```
总结：

| 使用方法                      | 等价使用方式                                      | 所有权     |
| ----------------------------- | ------------------------------------------------- | ---------- |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | 转移所有权 |
| `for item in &collection`     | `for item in collection.iter()`                   | 不可变借用 |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | 可变借用   |

​	如果想在循环中**获取元素的索引**：

```rust
fn main() {
    let a = [4, 3, 2, 1];
    // `.iter()` 方法把 `a` 数组变成一个迭代器
    for (i, v) in a.iter().enumerate() {
        println!("第{}个元素是{}", i + 1, v);
    }
}
```

### `continue`

使用 `continue` 可以跳过当前当次的循环，开始下次的循环：

```rust
 for i in 1..4 {
     if i == 2 {
         continue;
     }
     println!("{}", i);
 }
```

### `break`

使用 `break` 可以直接跳出当前整个循环：

```rust
 for i in 1..4 {
     if i == 2 {
         break;
     }
     println!("{}", i);
 }
```

## `while` 循环

如果你需要一个条件来循环，当该条件为 `true` 时，继续循环，条件为 `false`，跳出循环，那么 `while` 就非常适用：

```rust
fn main() {
    let mut n = 0;
    while n <= 5  {
        println!("{}!", n);
        n = n + 1;
    }

    println!("我出来了！");
}
```

## `loop` 循环

​	对于循环而言，`loop` 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， `for` 和 `while` 才是最优选择），因为 `loop` 就是一个简单的无限循环，你可以在内部实现逻辑通过 `break` 关键字来控制循环何时结束。

​	使用 `loop` 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

​	因此，当使用 `loop` 时，必不可少的伙伴是 `break` 关键字，它能让循环在满足某个条件时跳出：

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```



这里有几点值得注意：

- **break 可以单独使用，也可以带一个返回值**，有些类似 `return`
- **loop 是一个表达式**，因此可以返回一个值



> 参考资料：
>
> 1. https://course.rs/basic/flow-control.html
> 2. https://practice-zh.course.rs/flow-control.html