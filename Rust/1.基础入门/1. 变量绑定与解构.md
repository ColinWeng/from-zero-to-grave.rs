[TOC]

## 为何要手动设置变量的可变性？

​	在大多数语言中，要么只支持声明可变的变量，要么只支持声明不可变的变量，前者为编程提供灵活性，后者为编程提供安全性。Rust 两者都要。

​	除了上述两个优点，还有一个很大的优点，就是运行性能额提升，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 `runtime` 检查。

## 变量绑定

​	在其他语言中，用 `var a="hello world"` 的方式给 `a` 赋值，也就是把等式右边的字符串赋值给变量 `a`；而在Rust中，这样写`let a = "hello world"`，同时给这个过程起了另一个名称：**变量绑定**。 

​	为何不用赋值而用绑定呢？这就设计 Rust 最核心的原则——**所有权**，简单说，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人。

## 变量可变性

​	Rust的变量在默认情况下是不可变的。必须通过 `mut` 关键字让变量变为可变。

```rust
fn main() {
    // 这里不加 mut 就会编译失败，因为默认变量不可变
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

## 使用下划线开头忽略未使用的变量

​	如果创建一个变量却不在任何地方使用它，Rust 通常会给一个警告。如果你希望不警告未使用的变量，为此可以用下划线作为变量名的开头。

```rust
fn main() {
  	// 会忽略告警
    let _x = 5;
  	// 存在告警
    let y = 10;
}
```

## 变量解构

​	`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容。

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### 解构式赋值

​	在 Rust 1.59 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式。

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

## 变量和常量之间的差异

* 常量不允许使用 `mut`。 常量自始至终不可变。
* 常量使用 `const` 关键字。并且值的类型必须标注。

```rust
const MAX_POINTS: u32 = 100_000;
```

## 变量遮蔽（shadowing）

​	Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的变量。

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);  // 12
    }

    println!("The value of x is: {}", x);  // 6
}
```

​	这和 `mut` 变量的使用是不同的，第二个`let`生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配，而`mut`声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能更好。



> 参考资料：
>
> 1. https://course.rs/basic/variable.html
> 2. https://practice-zh.course.rs/variables.html

