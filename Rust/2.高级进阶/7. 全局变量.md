[TOC]

​	全局变量的生命周期肯定是`'static`，但是不代表它需要用`static`来声明，例如常量、字符串字面值等无需使用`static`进行声明，原因是它们已经被打包到二进制可执行文件中。

## 编译器初始化

​	我们大多数使用的全局变量都只需要在编译期初始化即可，例如静态配置、计数器、状态值等等。

### 静态常量

```rust
// 常量，顾名思义它是不可变的，很适合用作静态配置
const MAX_ID: usize =  usize::MAX / 2;
fn main() {
   println!("用户ID允许的最大值是{}",MAX_ID);
}
```

**常量与普通变量的区别**

- 关键字是`const`而不是`let`
- 定义常量必须指明类型（如 i32）不能省略
- 定义常量时变量的命名规则一般是全部大写
- 常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址
- 常量的赋值只能是常量表达式/数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式
- 对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义

### 静态变量

```rust
// 静态变量允许声明一个全局的变量，常用于全局数据统计
static mut REQUEST_RECV: usize = 0;
fn main() {
   // Rust 要求必须使用`unsafe`语句块才能访问和修改`static`变量
   // 因为这种使用方式往往并不安全，其实编译器是对的，当在多线程中同时去修改时，会不可避免的遇到脏数据。
   unsafe {
        REQUEST_RECV += 1;
        assert_eq!(REQUEST_RECV, 1);
   }
}
```

**静态变量和常量的区别**

- 静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向同一个地址
- 存储在静态变量中的值必须要实现 `Sync trait`

### 原子类型

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
// 想要全局计数器、状态控制等功能，又想要线程安全的实现，原子类型是非常好的办法。
static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);

fn main() {
    for _ in 0..100 {
        REQUEST_RECV.fetch_add(1, Ordering::Relaxed);
    }

    println!("当前用户请求数{:?}",REQUEST_RECV);
}
```

## 运行期初始化

```rust
use std::sync::Mutex;
// 静态初始化有一个致命的问题：无法用函数进行静态初始化，例如你如果想声明一个全局的`Mutex`锁
static NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));

fn main() {
    let v = NAMES.lock().unwrap();
    println!("{}",v);
}
```

```console
error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
 --> src/main.rs:3:42
  |
3 | static NAMES: Mutex<String> = Mutex::new(String::from("sunface"));
```

​	但你又必须在声明时就对`NAMES`进行初始化，此时就陷入了两难的境地。好在天无绝人之路，我们可以使用`lazy_static`包来解决这个问题。

### `lazy_static`

​	[`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs)是社区提供的非常强大的宏，用于懒初始化静态变量，之前的静态变量都是在编译期初始化的，因此无法使用函数调用进行赋值，而`lazy_static`允许我们在运行期初始化静态变量！

```rust
use std::sync::Mutex;
use lazy_static::lazy_static;
// 在运行期初始化静态变量
lazy_static! {
    static ref NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
}

fn main() {
    let mut v = NAMES.lock().unwrap();
    v.push_str(", Myth");
    println!("{}",v);
}
```

​	当然，使用`lazy_static`在每次访问静态变量时，会有轻微的性能损失，因为其内部实现用了一个底层的并发原语`std::sync::Once`，在每次访问该变量时，程序都会执行一次原子指令用于确认静态变量的初始化是否完成。

​	`lazy_static`宏，匹配的是`static ref`，所以定义的静态变量都是不可变引用

​	为何需要在运行期初始化一个静态变量，除了上面的全局锁，你会遇到最常见的场景就是：**一个全局的动态配置，它在程序开始后，才加载数据进行初始化，最终可以让各个线程直接访问使用**

```rust
use lazy_static::lazy_static;
use std::collections::HashMap;

// 使用`lazy_static`实现全局缓存
lazy_static! {
    static ref HASHMAP: HashMap<u32, &'static str> = {
        let mut m = HashMap::new();
        m.insert(0, "foo");
        m.insert(1, "bar");
        m.insert(2, "baz");
        m
    };
}

fn main() {
    // 首次访问`HASHMAP`的同时对其进行初始化
    println!("The entry for `0` is \"{}\".", HASHMAP.get(&0).unwrap());

    // 后续的访问仅仅获取值，再不会进行任何初始化操作
    println!("The entry for `1` is \"{}\".", HASHMAP.get(&1).unwrap());
}
```

### `Box::leak`

​	在`Box`智能指针章节中，我们提到了`Box::leak`可以用于全局变量，例如用作运行期初始化的全局动态配置，先来看看如果不使用`lazy_static`也不使用`Box::leak`，会发生什么：

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}

// 声明了一个全局动态配置`CONFIG`，并且其值初始化为`None`
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    unsafe {
        // 然后在程序开始运行后，给它赋予相应的值
        CONFIG = Some(&mut Config {
            a: "A".to_string(),
            b: "B".to_string(),
        });

        println!("{:?}", CONFIG)
    }
}
```

```console
error[E0716]: temporary value dropped while borrowed
  --> src/main.rs:10:28
   |
10 |            CONFIG = Some(&mut Config {
   |   _________-__________________^
   |  |_________|
   | ||
11 | ||             a: "A".to_string(),
12 | ||             b: "B".to_string(),
13 | ||         });
   | ||         ^-- temporary value is freed at the end of this statement
   | ||_________||
   |  |_________|assignment requires that borrow lasts for `'static`
   |            creates a temporary which is freed while still in use
```

​	好在`Rust`为我们提供了`Box::leak`方法，它可以将一个变量从内存中泄漏(听上去怪怪的，竟然做主动内存泄漏)，然后将其变为`'static`生命周期，最终该变量将和程序活得一样久，因此可以赋值给全局静态变量`CONFIG`。

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    unsafe {
        // 将`c`从内存中泄漏，变成`'static`生命周期
        CONFIG = Some(Box::leak(c));
    }
}
```

### 从函数中返回全局变量

​	问题又来了，如果我们需要在运行期，从一个函数返回一个全局变量该如何做？例如：

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}

static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    Some(&mut Config {
        a: "A".to_string(),
        b: "B".to_string(),
    })
}

fn main() {
    unsafe {
        CONFIG = init();

        println!("{:?}", CONFIG)
    }
}
```

​	报错这里就不展示了，跟之前大同小异，还是生命周期引起的，那么该如何解决呢？依然可以用`Box::leak`:

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}

static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    Some(Box::leak(c))
}

fn main() {
    unsafe {
        CONFIG = init();
    }
}
```

## 标准库中的 Once 和 Lazy

​	在 Rust 1.70.0 版本之前，标准库通过实验性 API 提供 `lazy::OnceCell` 和 `lazy::SyncOnceCell` 来实现单次初始化容器，这时，懒初始化主要依靠 `lazy_static` 。 随着 `cell::OnceCell` 和 `sync::OnceLock` 在 1.70.0 中稳定和 `LazyCell` 和 `LazyLock` 在 1.80.0 中稳定，只使用标准库实现懒加载成为可能。

​	这4个容器可以这样区分：

|      | 单线程   | 多线程   |
| ---- | -------- | -------- |
| Once | OnceCell | OnceLock |
| Lazy | LazyCell | LazyLock |

​	其中，`Lazy` 会自动按需加载内容，让代码更简洁，更人性化，而 `Once` 则可以手动指定初始化的时机或使用不同的方法初始化，更强大。 `Cell` 的实现更简单，效率也更高，但是他并不保证线程安全，而 `Lock` 通过内部同步机制实现了线程安全。

### Once 使用方法

```rust
use std::{sync::OnceLock, thread};

fn main() {
    // 子线程中调用
    let handle = thread::spawn(|| {
        // 调用 `Logger::global()` 获取其实例
        let logger = Logger::global();
        logger.log("thread message".to_string());
    });

    // 调用 `Logger::global()` 获取其实例
    let logger = Logger::global();
    logger.log("some message".to_string());

  	// 调用 `Logger::global()` 获取其实例
    let logger2 = Logger::global();
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

// 由于需要在多个线程中使用，所以我们使用了 `OnceLock`
static LOGGER: OnceLock<Logger> = OnceLock::new();

impl Logger {
    // 声明了一个 `global()` 关联函数
    fn global() -> &'static Logger {
        // 调用 `get_or_init` 进行初始化 `Logger`
        LOGGER.get_or_init(|| {
            println!("Logger is being created..."); // 初始化打印
            Logger
        })
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

```console
Logger is being created...
some message
other message
thread message
```

### Lazy 使用方法

​	上述例子如果使用 `LazyLock` 来实现，则可以变得更加简洁：

```rust
use std::{sync::LazyLock, thread};

fn main() {
    // 子线程中调用
    let handle = thread::spawn(|| {
        // 使用的时候，可以直接使用对全局变量的引用。在获取引用的时候， `LazyLock` 会自动检查初始化的状态并进行初始化。
        let logger = &LOGGER;
        logger.log("thread message".to_string());
    });

    // 使用的时候，可以直接使用对全局变量的引用。在获取引用的时候， `LazyLock` 会自动检查初始化的状态并进行初始化。
    let logger = &LOGGER;
    logger.log("some message".to_string());

    // 使用的时候，可以直接使用对全局变量的引用。在获取引用的时候， `LazyLock` 会自动检查初始化的状态并进行初始化。
    let logger2 = &LOGGER;
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

// 使用 `LazyLock::new` 方法直接对全局变量 `LOGGER` 进行赋值，并传入一个初始化函数
static LOGGER: LazyLock<Logger> = LazyLock::new(Logger::new);

impl Logger {
    fn new() -> Logger {
        println!("Logger is being created...");
        Logger
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

## 总结

简单来说，全局变量可以分为两种：

- 编译期初始化的全局变量，`const`创建常量，`static`创建静态变量，`Atomic`创建原子类型
- 运行期初始化的全局变量，`lazy_static`用于懒初始化，`Box::leak`利用内存泄漏将一个变量的生命周期变为`'static`



> 参考资料：
>
> 1. https://course.rs/advance/global-variable.html
