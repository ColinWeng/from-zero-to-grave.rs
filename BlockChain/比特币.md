[TOC]

# 密码学基础：Hash和签名

​	比特币是一种加密货币，使用了密码学的 Hash 和签名功能。

## Hash 函数

​	特性一，哈希碰撞（**collsion resitance**），不同输入通过Hash函数，产生相同输出。 因为输入空间远远大于输出空间，所以哈希碰撞是不可避免的。

​	特性二，隐藏（**hiding**），`X -> Hash(X)`，输入 X 经过Hash函数计算出函数值，无法通过哈希值反推出 X 的值。（前提：输入空间足够大）

​	以上两个特性组合，就变成了 数字签名（digital commitment）。

​	特性三，**puzzle friendly**，在知道输入和Hash函数的前提下，输出是不可预知的。比如，希望计算出 "00...0XX...X" 的哈希值（前面包含k个0），必须一个一个尝试计算。这个特性也是比特币挖矿的工作量证明的基础。

​	**difficult to solve, but easy to verify**，找到满足条件的输入很难，验证输入和哈希值却很容易。

​	比特币使用 **SHA-256** 哈希算法。

## 签名（非对称加密）

​	比特币是去中心化的，创建比特币账户，只需要创建公私钥对（public key ，private key）。

> 公钥是公开的。
>
> 举例， A 给 B 发消息：
>
> ​	A 用 B 的公钥加密， B 收到消息，用B的私钥解密。

​	比特币中，用户A发起交易，需要用A私钥对交易进行签名，再将交易发布出去。其他人收到交易，需要用A的公钥对交易进行验证。



​	总结：私钥签名交易，公钥验证交易。

# 数据结构

## 哈希指针（hash pointers）

​	传统的指针 **P**，指向的是 结构体 在内存中的地址。

​	哈希指针 **H()**，除了保存地址，还要保存**哈希值**。这样不管可以找到结构体，还要判断**数据是否被篡改**。

​	**Black Chain is a linked list useing hash pointers.**  区块链就是一个用 哈希指针链接的链表。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E5%93%88%E5%B8%8C%E6%8C%87%E9%92%88.png" alt="哈希指针" style="zoom: 50%;" />

​	区块链中的任何一个节点被修改，都会导致后面的哈希值被修改，所以只需保存最后一个节点的哈希值就能知道区块链是否被修改。

## 默克尔树（Merkle Tree）

​	Merkle tree 和 binary tree 的区别是，指针替换成哈希指针。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91.png" alt="默克尔树" style="zoom:50%;" />

​	只需要记录最上面的**根哈希值**，就能判断这个结构是否被修改。

​	比特币中各个区块通过**哈希指针串联**，每个区块中的**交易**被打包成**默克尔树**结构。

​	**block header**：包含根哈希值，无交易数据

​	**block body**：包含交易数据。

### 默克尔证明（Merkle proof）

​	**全节点**保存 block header 和 block body，**轻节点**只保存 block header。轻节点需要证明交易存在。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E9%BB%98%E5%85%8B%E5%B0%94%E8%AF%81%E6%98%8E.png" alt="默克尔证明" style="zoom: 50%;" />	

​	轻节点收到 Merkle proof（包含 tx、橙色的H()、根哈希值），只需要本地计算绿色H()和根哈希比较就能**验证交易是否存在**。

​	所以，Merkle proof（Proof of membership） 可以证明交易是否包含在 Merkle tree 中。验证的复杂度是 `log(n)`，是高效的。

如果要证明不包含，需要遍历所有，复杂度是 `n`。另一种方式，是 Sorted Merkle Tree，通过排序判断交易是否在两个块之间。（比特币没有使用 Sorted Merkle Tree ）

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E6%8E%92%E5%BA%8F%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91.png" alt="排序默克尔树" style="zoom:50%;" />

# 协议

​	去中心化的数字货币**要解决的问题**：

1. 数字货币的发行，谁有权利发行
2. 如何验证交易有效性，防止双花



> **双花攻击**：
>
> ​	与传统纸币不同，数字货币没有纸币的媒介，数字货币都是数据文件，数据就容易 copy，一旦 copy 就会有多份相同的数据，就会有多次花费的场景。
>
> ​	以央行发行数字货币举例，给每个数字货币上设定序号，并关联持有人信息。使用后，变更持有人，可以通过中心化解决双花问题。但是比特币通过去中心化的方式解决这个问题。



​	比特币的**共识内容**：

1. 去中心化账本的内容（交易）
2. 拥有记账权的节点，才能写入账本
3. 通过算力，决定记账权



## 比特币交易

​	

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8F%8C%E8%8A%B1-2.png" alt="比特币双花" style="zoom:50%;" />

​	比特币中A首次出现的交易，叫做**铸币交易**，这个时候A账户上的币是凭空产生的（挖矿产生）。

​	以上图为例，后面的区块中，B、C、C的所有交易，最终源头都指向A的铸币交易。

> 备注：
>
> ​	上面的结构中有2个哈希，一个是块之间的哈希，另一个就是交易中使用币的哈希。每个使用的币，都要指向它上一个交易的输出哈希。

​	

​	一个A向B交易需要的信息：

* 输入部分：
  * 币的来源，当前币的上一笔交易的输出地址。
  * 转账人 A 的公钥，这个公钥需要和币来源的公钥一致，证明使用的币是A持有的。
* 输出部分：
  * 收款人的公钥哈希

​	比特币中的输入和输出是脚本，验证的时候把两个脚本一起执行。



### block header 和 block body

​	上面的数据结构介绍了，交易（tx）会被打包，组装在 默克尔树的底部，最上层是默克尔树的根哈希。每个块头上都会有前一个块头的哈希。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/block%20header.png" alt="block header" style="zoom:50%;" />

* block header

  - 比特币版本（version）

  - 前一个区块头哈希（hash of previous Block header）

  - 默克尔树哈希（merkle root hash）

  - 目标值（target）

  - 随机数（noce）


* block body
  * 交易（tx）

## 比特币中的共识协议

​	共识是为了让所有节点数据保持一致。比特币假设存在恶意节点。



* 如果用投票方案实现：类似于分布式系统中的二阶段
  * 存在的问题
    * 谁有投票权（membership 问题）？
      * 如果是账号的话，那产生超过半数的账号，就能发动 女巫攻击 （sybil attack）。

* 比特币使用算力投票。
  * 通过定义 target，利用哈希函数，让节点不断尝试随机数（`nonce`），计算 `H（Block header）<= target`。
    * 谁先计算出，谁就拥有记账权
  * 因为是通过算力，会存在2个节点同时计算出随机值，各自发布自己的区块，然后网络中的节点会选择不同的区块作为下一步挖矿的节点。
    * 为了解决短暂分叉，比特币中采用 最长合法链（longest valid chain）原则，当出现分叉，选择最长的链。



### 分叉攻击（forking attack）

​	针对区块链的结构以及最长合法链，就出现了分叉攻击。

​	从中间节点分叉，并且产生更长的链。

​	<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/image-20250831142832004.png" alt="image-20250831142832004" style="zoom:50%;" />



### 出块奖励（Block reward）

​	为了奖励矿工，设计了出块奖励，

- coinbase transaction，发行的唯一方法。
- 一开始一个快 50BTC ，每21W个区块后奖励减半 25BTC 



# 协议实现

​	比特币是基于交易的分类账本（transaction-based ledger）。这里交易包含铸币交易和转账交易。

​	因为这个交易模型，没有固定账户的概念，当需要知道某个地址的账户余额时，就需要监测该地址的所有交易。

## UTXO（Unspent Transaction Output）

​	比特币的交易结构叫做 UTXO（Unspent Transaction Output），包含输入和输出，输出可以是多个。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/UTXO.png" alt="UTXO" style="zoom:50%;" />

​	每笔交易都会消耗 UTXO，也会产生新的 UTXO。

​	比特币上的全节点内存会维护 UTXO 结构，也就是所有未使用的比特币。如果部分人的UTXO一直不使用就会一直存在。

## 出块奖励（Block reward）

​	比特币设计，平均10分钟一个区块。

​	每21W个区块，奖励减半。（21W * 10分钟）/ （60分钟 * 24小时 * 365天） 约等于 4年，4年一次减半。

​	比特币总数：21W * 50 + 21W * 25 + 21W * 12.5 + ...... = 2100W 



## 交易费（Transaction Fee）

​	除了出块奖励，比特币还涉及**交易费**。这是为了避免恶意节点只打包自己的交易。

​	每个 UTXO 中，有 total inputs 和  total outputs。当你查看网上的交易，会发现，total outputs 会小于等于 total inputs 。因为比特币规定，小于的这部分就是矿工的交易费。

​	当网络中有大量待处理的交易时，旷工会优先处理交易费高的。



## 块信息（Block Info）

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/block%20example.png" alt="block example" style="zoom: 33%;" />

* Summary
  * Number of Transactions ：包含的交易数
  * Output Total：总输出
  * Estimated Transaction Volume：
  * Transaction Fees：总交易费
  * Height：块高
  * Timestamp：时间戳
  * Diffculty：挖矿难度
  * Nonce：挖矿尝试的随机数
  * Block Reward：出块奖励
* Hashs
  * Hash ：块头哈希值
  * Previous Block ： 前一个区块的块头哈希值
  * Merkle Root：默克尔树的 根哈希值



## 块头（Block header）

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/block%20header-2.png" alt="block header-2" style="zoom:50%;" />

* version：使用的比特币版本
* previous block header hash：前一个块头哈希
* merkle root hash：默克尔树的根哈希
* time：创建区块的时间
* nBits：挖矿的目标阈值，编码后的版本
* nonce：挖矿的随机数。

### 挖矿随机数

​	由于挖矿竞争激烈，难度被调整的很高，**nonce** 的取值范围已经不足以挖矿。下一个能改的地方就是 **merkle root hash**。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/header%20coinbase.png" alt="header coinbase" style="zoom:50%;" />

​	每个块都有一个铸币交易（CoinBase），这里域的内容其他节点不会检查，可以充当随机数修改，这里修改也会导致 默克尔根哈希变化。

## 交易（Transaction）

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93-2.png" alt="交易-2" style="zoom:50%;" />

​	交易中的输入和输出都是用脚本的形式指定的。比特币中验证交易合法性，是将 输入脚本和输出脚本进行配对执行。

> 备注：
>
> ​	配对的脚本是，当前交易中的**输入脚本** 以及 上一个交易的**输出脚本**。



## 确认（confirmation）

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E7%A1%AE%E8%AE%A42.png" alt="交易确认2" style="zoom:50%;" />

​	比特币认为6个区块之后数据是不可篡改的，所以最终确认平均要等到1小时。



* Zero confirmation：收到交易但是为打包



> Selfish mining 攻击，挖到区块后先藏着。



# 网络

* 应用层：比特币网络
* 网络层：P2P Overlay 网络

​	如果网络中同时存在 `A->B`，`A->C` 的交易，那不同节点以先收到的数据为准，后收到的节点会被拒绝。

​	比特币区块有1M的大小限制。



# 挖矿难度

​	挖矿，就是不断尝试 `block header` 中的 `nonce` 值，使整个 `block header` 的哈希值 小于等于给定的目标阈值（`H(block header) <= target`）。

​	比特币使用的是 `SHA-256`，输出空间是 `2^256` 的取值。

> 挖矿难度和目标阈值成反比。



​	**为什么要调整难度？**

> ​	如果不调整难度，随着全网算力的提升，会有更多人挖出区块，更容易产生分叉。然后，不同节点选择不同的分叉节点继续挖矿，全网算力会被分散。恶意节点就可以针对某个分叉造成分叉攻击，因为好的节点算力被分散了，出块速度比不上恶意节点的速度。
>
> ​	51% attack。

​	

​	**怎么调整难度？**
$$
target = target \times(actual time)\div(expected time)
$$

* actual time：实际出块时间（2016块）
* expected time：期望出块时间，(2016 * 10) / (60 * 24) = 14 天

​	如果实际出块时间比 2星期小，target 就会变小，上调和下调有 4倍限制。



​	block header 中没有实际存储 `target (256)`，而是存储在 `nBits(4)` 中，是 target 的压缩编码。

# 挖矿

* 全节点

  * 一直在线
  * 在本地硬盘上维护完整的区块链信息
  * 在内存里维护 UTXO 集合，以便快速验证交易的正确性
  * 监听比特币网络上的交易信息，验证每个交易的合法性
  * 决定哪些交易会被打包到区块里
  * 监听别的矿工挖出来的区块，验证其合法性（区块每个交易合法、发布区块难度要求、难度目标）
  * 挖矿
    * 决定沿着哪条链挖下去？（最长合法链）
    * 当出现等长的分叉的时候，选择哪一个分支？（先监听到的节点）

* 轻节点

  * 不是一直在线
  * 不用保存整个区块链，只要保存每个区块的块头
  * 不用保存全部交易，只保存与自己相关的交易
  * 无法校验大多数交易的合法性，只能校验与自己相关的那些交易的合法性。
  * 无法检测网上发布的区块的正确性
  * 可以验证挖矿的难度
  * 只能检测哪个是最长链，不知道哪个是最长合法链

  

挖矿设备变化

* CPU
* GPU
* ASIC 芯片
* 矿池



# 脚本语言

​	比特币的脚本语言只有栈结构。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93-2.png" alt="交易-2" style="zoom:50%;" />

## 交易结构

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E7%BB%93%E6%9E%84.png" alt="交易结构" style="zoom: 25%;" />



* locktime：交易的生效时间，0 表示立即生效。
* vin：输入结构
* vout：输出结构
* blockhash：当前交易所在的区块
* confirmations：当前交易的确认信息
* time：交易时间
* blocktime：区块创建时间

### 交易输入

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E8%BE%93%E5%85%A5.png" alt="交易输入" style="zoom: 25%;" />

​	交易的输入是一个数组，每个交易输入都要说明来源。

* txid：前一个交易的哈希值
* vout：前一个交易中的第几个输出
* scriptSig：交易签名
  * asm：
  * hex：

### 交易输出

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E8%BE%93%E5%87%BA.png" alt="交易输出" style="zoom: 25%;" />



* value：输出金额
* n：当前交易的序号
* scriptPubkey
  * asm：脚本命令
  * hex
  * regSig：需求的签名
  * type：脚本类型
  * addresses：输出的地址

### 交易验证

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E9%AA%8C%E8%AF%81.png" alt="交易验证" style="zoom: 25%;" />

​	验证 `B->C` 的校验，需要验证**当前交易的输入脚本**（`input script`），以及**上一个交易的输出脚本**（`output script`）。

## 脚本形式

### P2PK（Pay to Public Key）

​	最简单的形式，输出脚本直接给出公钥。



* input script
  * PUSHDATA(sig)，用私钥对交易进行签名。
* output script
  * PUSHDATA(PubKey)，直接给出公钥
  * CHECKSIG



脚本执行：

1. PUSHDATA(sig)，来源input script，Sig 压入栈

2. PUSHDATA(PubKey)，来源output script，PubKey 压入栈

3. CHECKSIG，来源output script，将 Sig 和 PubKey 弹出栈，并用公钥验证签名



### P2PKH（Pay to Public Key Hash）

​	与P2PK的区别是，输出脚本给出的是收款人的公钥哈希。P2PKH 是最常用的脚本形式。

- input script

  - PUSHDATA(sig)，用私钥对交易签名
  - PUSHDATA(PubKey)，公钥

- output script

  - DUP   栈顶元素复制 
  - HASH160
  - PUSHDATA(PubKeyHash)
  - EQUALVERIFY 
  - CheckSig

  

脚本执行：

1. PUSHDATA(sig)，来源input script，Sig 压入栈

2. PUSHDATA(PubKey)，来源input script，PubKey 压入栈
3. DUP，来源output script，栈顶元素复制一次
4. HASH160，来源output script，栈顶元素弹出，计算Hash，压入栈
5. PUSHDATA(PubKeyHash)，来源output script，PubKeyHash 压入栈
6. EQUALVERIFY，来源output script，弹出2个栈顶元素，并校验Hash
7. CheckSig，来源output script，将 Sig 和 PubKey 弹出栈，并用公钥验证签名



### P2SH（Pay to Script Hash）

​	采用 BIP 16 的方案。

​	最复杂的脚本形式，输出脚本给的不是收款人的公钥哈希，而是收款人提供的脚本哈希，赎回脚本（**redeemScripth）。



- input script（花钱的时候需要提供脚本）
  - ...
  - PUSHDATA(sig)
  - ...
  - PUSHDATA（serkalized redeemScript）
- output script
  - HASH160
  - PUSHDATA(redeemScripthHash)
  - EQUAL



​	进一步说明：

> * input script 要给出一些签名（数目不定）以及一段序列化的 redeemScript。验证分如下两步：
>   * 验证序列化的 redeemScript 是否与 output script 中的哈希值匹配？
>   * 反序列化并执行 redeemScript，验证 input script 中给出的签名是否正确？
> * redeemScript 的形式
>   * P2PK 形式
>   * P2PKH 形式
>   * 多重签名形式



#### 用 P2SH实现P2PK

* redeemScript
  * PUSHDATA（PubKey）
  * CheckSig
* input script
  * PUSHDATA（Sig）
  * PUSHDATA（serialized redeemScript）
* output script
  * HASH160
  * PUSHDATA（redeemScriptHash）
  * EQUAL



脚本执行：

1. 第一阶段的验证
   1. PUSHDATA（Sig），来源input script，Sig 压入栈
   2. PUSHDATA（serialized redeemScript），来源input script，序列化的赎回脚本压入栈
   3. HASH160，来源output script，栈顶元素弹出，计算Hash，压入栈
   4. PUSHDATA（redeemScriptHash），来源output script，
   5. EQUAL，来源output script，验证Hash
2. 第二阶段的验证（需要将 redeemScript 反序列化）
   1. PUSHDATA（PubKey），来源 redeemScript
   2. CheckSig，来源 redeemScript



#### 多重签名

##### 早期多重签名	

​	早期的多重签名，目前已经不推荐使用。

* input script
  * X，比特币代码bug，第一个弹出堆栈，需要一个无用元素。
  * PUSHDATA（Sig_1）
  * PUSHDATA（Sig_2）
  * ...
  * PUSHDATA（Sig_M）
* output script
  * M
  * PUSHDATA（pubkey_1）
  * PUSHDATA（pubkey_2）
  * ...
  * PUSHDATA（pubkey_N）
  * N
  * CheckMultiSig



脚本执行：

1. False，多余元素，
2. PUSHDATA（Sig_1）
3. PUSHDATA（Sig_2）
4. 2，阈值 M
5. PUSHDATA（pubkey_1）
6. PUSHDATA（pubkey_2）
7. PUSHDATA（pubkey_3）
8. 3，阈值N
9. CheckMultiSig，验证是否是3个中的2个签名



> ​	对用户来说，交易的时候，需要知道对方的多个公钥。



##### 用P2SH实现多重签名

​	本质，将复杂度从 output script 转移到了 **赎回脚本（redeemScript**）。 赎回脚本（redeemScript） 是由收款人提供的，并在输入脚本中使用。

​	对用户来说，只需要知道 **赎回脚本哈希值（redeemScriptHash**）。

* redeemScript
  * M
  * PUSHDATA（pubkey_1）
  * PUSHDATA（pubkey_2）
  * ...
  * PUSHDATA（pubkey_N）
  * N
  * CheckMultiSig
* input script
  * X，比特币代码bug，第一个弹出堆栈，需要一个无用元素。
  * PUSHDATA（Sig_1）
  * PUSHDATA（Sig_2）
  * ...
  * PUSHDATA（Sig_M）
  * PUSHDATA（serialized redeemScript）
* output script
  * HASH160
  * PUSHDATA（redeemScriptHash）
  * EQUAL



脚本执行：

1. 第一阶段验证
   1. False，多余元素，
   2. PUSHDATA（Sig_1）
   3. PUSHDATA（Sig_2）
   4. PUSHDATA（seriRS）
   5. HASH160
   6. PUSHDATA（RSH）
   7. EQUAL
2. 第二阶段验证，（把赎回脚本展开后验证）
   1. 2
   2. PUSHDATA（pubkey_1）
   3. PUSHDATA（pubkey_2）
   4. PUSHDATA（pubkey_3）
   5. 3
   6. CheckMultiSig



### Proof of Burn

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/Proof%20of%20Burn.png" alt="Proof of Burn" style="zoom: 25%;" />

* output script
  * Return，无条件返回错误，后面内容不会执行，该交易永远无法使用，也是销毁比特币的方式。



作用：

* 销毁比特币

- digital commitment (知识产权的hash) ，写在 Return 后面
  - 与 coinbase 域相比，该方式所有节点都能用。（发布区块需要记账权，发布交易不需要）

#### 例子



<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE.png" alt="交易中写数据" style="zoom: 25%;" />

​	这个例子中，output script 中使用 Return，并在后面写入了自定义的内容。 



<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/%E4%BA%A4%E6%98%93%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE2.png" alt="交易中写数据2" style="zoom: 25%;" />

​	这个例子中，输出金额为0，表示输入金额都是交易费用。这样的数据，全节点就不需要在内存中维护 这个 UTXO。

# 分叉



* state fork ，短暂分歧导致临时分叉
  * forking attack ，分叉攻击
* protocd fork，协议修改导致分叉
  * hard fork，硬分叉。（必须所有节点都更新）
    * 例子：比特币区块大小限制，1M -> 4M 。
    * 旧节点不更新软件（1M），分叉会一直存在。
  * soft fork，软分叉。（半数以上更新，就不会永久分叉）
    * 例子：P2SH



# 匿名性

​	比特币账户可以随时创建，但是所有的交易都是公开的。

## 破坏匿名性



1. 不同账户可以关联
   1. input :  add1(4), add2(5)  
      1. 属于同一个人
   2. output: add3(6), add4(3) 
      1. 找零的地址，可以分析出来。使用比特币 4 和 5，找零地址就是 add4。
   3. 分析常用钱包的生成规则。
2. 账户与人真实身份可以关联
   1. 资金转入和转出链
   2. 匿名性保持最好的是中本聪，因为没用过。
   3. 例子：丝路（Silk road）



## 提高匿名性

1. 应用层
   1. coin mixing ，与其他用户的币混合，服务有风险
      1. 部分支持 coin mixing  的在线钱包
      2. 交易所（进入和出来），前提交易所不泄露
2. 网络层
   1. IP地址，TOR 路由



零知识证明：

​	指一方（证明这）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是正确之外的任何信息。



# 思考问题

1. 哈希指针如何通过网络传播？
   1. 实际结构中，只有哈希值，没有指针。
   2. 全节点把区块内存存在（key，value）DB，levelDB
2. 区块恋
   1. 把私钥截断分给双方
   2. 私钥 256 为破解难度是 2^256，拆开后破解难度是 2^128。
   3. 应该用多重签名
3. 分布式共识
   1. 为什么能绕过分布式共识中不可能结论（CAP）？
      1. 比特币共识会被推翻，会分叉。所以不是真正的共识。
4. 比特币的稀缺性
   1. 稀缺的东西不适合做货币
   2. 货币要通货膨胀





> 参考资料：
>
> 1. [北京大学肖臻老师《区块链技术与应用》公开课](https://www.bilibili.com/video/av37065233?vd_source=9be1685e6d4edc7dc5e4b37362c797e5&spm_id_from=333.788.videopod.episodes)

