[TOC]

# 以太坊概述

​	与比特币相比，以太坊做了以下改进：

1. 出块时间从 10分钟 调整到 10几秒，并改造了共识协议（GHOST协议）
2. memory hard mining puzzle，对内存要求高，限制了 ASIC 芯片
3. 从 工作量证明 到权益证明
4. 智能合约（smart contract）

# 账户

​	比特币不是账户模型，需要统计UTXO中的交易，才能知道账户余额。

​	以太坊是基于账户模型（account-based ledger），针对 **双花攻击（double speading attack）**有较好的防御。但是还有一个 **重放攻击（replay attack）**。

​	通过 账户交易次数（nonce），避免重放攻击。



## 账户类型

* 外部账户（external owned account）
  * balance：余额
  * nonce ：交易次数
* 合约账户
  * balance：余额
  * nonce ：交易次数
  * code：代码
  * storage：存储
  * 不能主动发起交易。



## 设计原因

​	比特币可以随意创建账户，隐私性较好。 但是以太坊要支持智能合约，要求用户有稳定的账户。



# 状态树（账户状态）

​	以太坊维护的是账户模式，每个账户上维护账户余额。需要什么样子的数据结构？

​	需要实现的功能：账户地址（addr）到 账户状态（state）的映射。

​	

**如果用哈希表实现？** 存在的问题：

1. Merkle Proof 怎么提供？怎么证明账户余额？
   1. 将整个哈希表的数据组成一个 Merkle Tree。
   2. 如果有一个账户余额变化，整个 Merkle Tree 都会变化，代价太大（大部分数据不变）。
      1. 比特币的  Merkle Tree 是对交易的汇总（最多4k个），每次交易都是不同的，且不会被修改。
   3. 所有的以太坊账户构建 Merkle Tree ，数量级很大。
   4. 所以这个方案不行，构建所有账号的 Merkle Tree 代价太大。



不使用哈希表，直接用 Merkle Tree：

1. Merkle Tree 没有提供一个高效的查找和更新的方法。
2. Merkle Tree 是否需要排序？
   1. 不排序，构建出的 Merkle Tree 不唯一。
   2. 比特币每个节点 Merkle Tree 也是不一致的，但是拥有记账权的节点才能决定顺序。
3. 使用 Sorted Merkle Tree
   1. 新加入的账户，可能造成半数的结构发生变更。



## trie

​	信息检索（retrieval）。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/trie.png" alt="trie" style="zoom: 25%;" />

​	trie 结构特点

1. trie 节点的分支、数目，取决于 key 值的取值范围。
   1. 以太坊地址，40个十六进制，
2. trie 查询效率，取决于 key 的长度
3. 哈希表会碰撞，trie 不会碰撞
4. 不同节点，插入后是固定的
5. 更新操作的局部性较好



​	trie 的缺点：节点存储浪费。

## Patricia trie

​	路径压缩，树结构减少，减少访问内存次数。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-01/Patricia%20trie.png" alt="Patricia trie" style="zoom: 25%;" />

​	针对键值稀疏的场景优化效果较好。	

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/Patricia%20trie-2.png" alt="Patricia trie-2" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/Patricia%20trie-3.png" alt="Patricia trie-3" style="zoom: 25%;" />

​	以太坊的账户数量，2^160 ，分布足够稀疏。足够长，能减少碰撞。



## MPT（Merkle Patricia trie）

​	Merkle Tree 和 binary Tree 的区别是把**普通指针**换成了**哈希指针**。

​	Merkle Patricia trie 和 Patricia trie 的区别也是把**普通指针**换成了**哈希指针**，这样压缩后的树，也能计算**根哈希**。



​	MPT 作用：

1. 可以防止账户状态被篡改
2. 可以 证明账户余额（Merkle Proof）
3. 可以证明键值不存在



### Modify MPT

​	<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/MPT-2.png" alt="MPT-2" style="zoom:50%;" />

​	上图展示 4个账户，账户状态只显示余额。

* Extension Node：表示有使用路径压缩
* Breach Node ：跟在 Extension Node 后面，包含多个节点
* Leaf Node：叶子账户节点



​	每次发布新区块的时候，某些账户的值会发生变化，这个变化不是在原分支上改，而是新建分支进行修改。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/MPT-3.png" alt="MPT-3" style="zoom: 50%;" />

* State Root ：状态树的根哈希值
  * 两个相邻的区块，大部分的节点是共享的，只有发生改变的节点是新创建的。



​	以太坊的**世界状态**，是所有账户（包括普通账户和合约账户）当前状态的快照。整个世界状态就是一个**大的MPT**，其每个叶节点对应一个账户地址，每个账户节点的 value 是这个账户的状态（对于普通账户包括余额、nonce等，对于合约账户，还包括存储根）。



​	每一个**合约账户**，因为可以有自己的存储（即合约变量等持久化数据），以太坊会为每个合约账户专门维护一个**单独的MPT**，用来存储该合约的所有键值对（如 mapping、变量值）。

- 在大的世界状态MPT中，每个合约账户节点会有一个字段 *storageRoot*，指向这个合约自己的MPT的根节点哈希。
- 这样每个合约的变量实际是在自己的“小MPT”里管理的。



​	你可以理解为：“以太坊有一棵总的大树（世界状态树），每个合约账户是这棵树上的一个分支，这个分支自己的信息里又嵌了一棵‘私有小树’（它的MPT存储树），用来存自己合约的变量等。”



> **为什么要保留历史状态？**
>
> 因为可能发生分叉，分叉后，状态会回滚。回滚（undo）需要历史记录。
>
> 智能合约执行完（逻辑复杂，无法推算），无法推算出之前的状态，所以必须保存历史状态。



## Header 结构

```go
type Header struct {
	ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
	UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
	Coinbase    common.Address `json:"miner"`
	Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
	TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
	ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
	Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
	Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
	Number      *big.Int       `json:"number"           gencodec:"required"`
	GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
	GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
	Time        uint64         `json:"timestamp"        gencodec:"required"`
	Extra       []byte         `json:"extraData"        gencodec:"required"`
	MixDigest   common.Hash    `json:"mixHash"`
	Nonce       BlockNonce     `json:"nonce"`
}
```

* ParentHash：父区块块头的哈希值
* UncleHash：叔父区块的哈希值（GHOST协议中会涉及到）
* Coinbase：
* Root：状态树的根哈希
* TxHash：交易树的根哈希
* ReceiptHash：收据树的根哈希
* Bloom：布隆过滤器，高效查询符合条件的查询结果
* Difficulty：挖矿难度
* Number：
* GasLimit：汽油费限制
* GasUsed：使用汽油费
* Time：
* Extra：
* MixDigest：随机数计算的哈希值
* Nonce：挖矿随机数

## Block 结构

```go
type Block struct {
	header       *Header
	uncles       []*Header
	transactions Transactions
	withdrawals  Withdrawals

	witness *ExecutionWitness

	// caches
	hash atomic.Pointer[common.Hash]
	size atomic.Uint64

	ReceivedAt   time.Time
	ReceivedFrom interface{}
}
```



```go
type extblock struct {
	Header      *Header
	Txs         []*Transaction
	Uncles      []*Header
	Withdrawals []*Withdrawal `rlp:"optional"`
}
```



## RLP

​	上面是针对 （key，value）中的key存储，value 需要经过 RLP（ Recursive Length Prefix） 处理进行储存，最终存储的是 nested array of bytes 。



# 交易树和收据树

​	每发布一个区块，区块中的交易会组成一个**交易树**，所有交易执行完会生成一个**收据树**。交易树和收据树是一一对应，都是MTP结构。

​	考虑到智能合约执行复杂，增加收据树，**快速查询执行结果**。

​	状态树需要共享节点，交易树和收据树是独立的，因为每个交易都是不同的。



交易树和收据树的作用：

1. 提供 Merkle Proof
2. 提供智能合约的相关交易
   1. 先查块头中的 Bloom fitter 是有该智能合约的交易（发布的区块在块头中，有一个总的  Bloom fitter），过滤区块
   2. 再查收据树中的  Bloom fitter ，过滤交易



> 交易驱动的状态机（transaction-driven state machine）。
>
> ​	状态转移必须是确定的，因为所有旷工都要执行。



## 相关代码

​	block.go 中，NewBlock 函数里调用 DeriveSha 来得到交易树和收据树的根哈希值。

```go
func NewBlock(header *Header, body *Body, receipts []*Receipt, hasher TrieHasher) *Block {
	if body == nil {
		body = &Body{}
	}
	var (
		b           = NewBlockWithHeader(header)
		txs         = body.Transactions
		uncles      = body.Uncles
		withdrawals = body.Withdrawals
	)

  // 判断交易是否为空
	if len(txs) == 0 {
		b.header.TxHash = EmptyTxsHash
	} else {
    // 创建交易树，计算根哈希值
		b.header.TxHash = DeriveSha(Transactions(txs), hasher)
    // 创建交易列表
		b.transactions = make(Transactions, len(txs))
		copy(b.transactions, txs)
	}

 	// 收据列表
	if len(receipts) == 0 {
		b.header.ReceiptHash = EmptyReceiptsHash
	} else {
    // 创建收据列表，计算根哈希值
		b.header.ReceiptHash = DeriveSha(Receipts(receipts), hasher)
    // 创建 bloom filter
		b.header.Bloom = MergeBloom(receipts)
	}

  // 处理叔父区块
	if len(uncles) == 0 {
		b.header.UncleHash = EmptyUncleHash
	} else {
		b.header.UncleHash = CalcUncleHash(uncles)
		b.uncles = make([]*Header, len(uncles))
		for i := range uncles {
			b.uncles[i] = CopyHeader(uncles[i])
		}
	}
  
	......
	return b
}
```

​	DeriveSha 函数中把 交易和收据构建成 Trie。

```go
func DeriveSha(list DerivableList, hasher TrieHasher) common.Hash {
	hasher.Reset()

	valueBuf := encodeBufferPool.Get().(*bytes.Buffer)
	defer encodeBufferPool.Put(valueBuf)

	var indexBuf []byte
	for i := 1; i < list.Len() && i <= 0x7f; i++ {
		indexBuf = rlp.AppendUint64(indexBuf[:0], uint64(i))
		value := encodeForDerive(list, i, valueBuf)
		hasher.Update(indexBuf, value)
	}
	if list.Len() > 0 {
		indexBuf = rlp.AppendUint64(indexBuf[:0], 0)
		value := encodeForDerive(list, 0, valueBuf)
		hasher.Update(indexBuf, value)
	}
	for i := 0x80; i < list.Len(); i++ {
		indexBuf = rlp.AppendUint64(indexBuf[:0], uint64(i))
		value := encodeForDerive(list, i, valueBuf)
		hasher.Update(indexBuf, value)
	}
	return hasher.Hash()
}
```

​	收据结构，每个收据可以包含多个 Log，Bloom 是根据 这些 Log 哈希产生。

```go
type Receipt struct {
	Type              uint8  `json:"type,omitempty"`
	PostState         []byte `json:"root"`
	Status            uint64 `json:"status"`
	CumulativeGasUsed uint64 `json:"cumulativeGasUsed" gencodec:"required"`
	Bloom             Bloom  `json:"logsBloom"         gencodec:"required"`
	Logs              []*Log `json:"logs"              gencodec:"required"`
	TxHash            common.Hash    `json:"transactionHash" gencodec:"required"`
	ContractAddress   common.Address `json:"contractAddress"`
	GasUsed           uint64         `json:"gasUsed" gencodec:"required"`
	EffectiveGasPrice *big.Int       `json:"effectiveGasPrice"` 
	BlobGasUsed       uint64         `json:"blobGasUsed,omitempty"`
	BlobGasPrice      *big.Int       `json:"blobGasPrice,omitempty"`
	BlockHash        common.Hash `json:"blockHash,omitempty"`
	BlockNumber      *big.Int    `json:"blockNumber,omitempty"`
	TransactionIndex uint        `json:"transactionIndex"`
}
```

​	所有收据上的 Bloom 最终会汇总到 Header 中的 Bloom。



# GHOST

​	以太坊把出块时间降到了10几秒。虽然提高了处理时间，但是也带来了别的问题：底层网络是 P2P 的网络，传输需要十几秒时间。挖矿是概率，会同时存在多个旷工同时发布区块，所以临时分叉会变成常态，数目会更多。

​	这对共识协议是个挑战。

​	比特币针对分叉的数据，因为出块时间长，临时分叉不会很多，所以按作废的方式处理分叉节点。

​	以太坊因为临时分叉变常态，如果分叉都丢弃处理，那对个体旷工非常不公平。



> GHOST协议不是以太坊发明的。



**以太坊使用比特币共识存在的问题**：

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/%E9%87%87%E7%94%A8%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="采用比特币挖矿的问题" style="zoom:50%;" />

​	如果出现分叉，上下2个是个体旷工，中间是矿池。旷池的节点位置一般比较好，能更早的广播出去，被其他节点接受。导致矿池更容易成为最长合法链。

​	大型矿池收益就会越来越大。



**以太坊如何解决这个问题：**

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/GHOST.png" alt="GHOST" style="zoom:50%;" />

​	以太坊采用  GHOST 协议，针对分叉情况，定义了 uncle Block， uncle Block 可以得到 7/8 的出块奖励。新的节点如果包含  uncle Block 可以 额外得到 1/32 的出块奖励，最多包含2个 uncle Block。

 	核心思想是对挖出矿，但是没成为最长合法链的旷工安慰。有利于鼓励，出现分叉，进行及时合并。



**存在的缺陷：**

1. uncle block 只能包含2个。
2. 发布第二个区块的时候，必须监听到uncle block。
3. 矿池竞争关系，可能会抛弃敌对uncle区块。



**再次进行协议改造：**

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/GHOST-2.png" alt="GHOST-2" style="zoom:50%;" />



uncle block 的定义：必须和当前区块在7代以内有共同的祖先（合法的叔父，只有6个辈分）。



**为什么这么设计？**

1. 控制 uncle block 数量
2. 有利于鼓励合并，越早奖励越多（解决临时性分叉）



**以太坊的奖励：**

- block reward
- gas fee（uncle block  无法获得）



**叔父里面的交易要不要执行？**

- 叔父区块不执行，交易合法性也不校验。
- 只校验挖矿难度。



# 挖矿算法

​	比特币出现之后，挖矿设备演化到了 ASIC 芯片。已经违背了 **one cpu ，one vote** 的初衷。

​	新的挖矿算法的其中一个目标是  **抗ASIC （ASIC resistance）**。

## memory hard mining puzzle

​	其中一个方案是 “**memory hard mining puzzle**” ，ASIC 芯片修改是计算，对内存访问没有优势。

​	一个有名的例子：莱特币（**LiteCoin**）使用 **scrypt**（对内存要求很高的哈希函数）。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/LiteCoin.png" alt="LiteCoin" style="zoom: 50%;" />

​	**核心思想：**

1. 开设一个很大的数组（数组很大），填充一些伪随机数
   1. 利用一个种子 seed 值，填充头。
   2. 然后利用伪随机函数（Hash）依次填充下一个节点（每次都依赖前一个节点的值），造成前后依赖关系。
2. 读取的时候，先算出A的坐标，然后取A的值，经过计算，计算出B的坐标，依次取值。



​	**好处**：对挖矿是 memory hard， **坏处**：对轻节点也是 memory hard。

​	

​	违背了 “Difficulty to solve，but easy to verify”。

​	实际 莱特币（**LiteCoin**）使用的内存数组，只有**128K**。这对 ASIC 芯片并没有造成影响，最终还是出现了。



## 以太坊的改进

​	以太坊使用了2个数据集，**16M Cache**，**1G dataset**  DAG。并且这2个数据集都会**定期增长**。

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%95%B0%E6%8D%AE%E9%9B%86%E6%94%B9%E8%BF%9B.png" alt="以太坊数据集改进" style="zoom:50%;" />

**小 Cache 如何生成：**

​	小的 Cache 和 莱特币 生成规则类似，利用 seed 和伪随机函数依次填充。

​	Cache 中的元素按序生产，每个元素产生时与上一个元素相关。

​	每隔 3W个块会重新生成 seed（对原来的 seed 求哈希值），并利用新的 seed 生成新的Cache。

​	Cache初始大小为16M，每隔 3W个块重新生成时增大初始大小的 1/128。

**大的 dataset（DAG） 如何生成：**

​	从 Cache 中按照规律（和莱特币挖矿类似）读取 256 个数，然后填充到大数组中。

​	先通过 Cache 中第 i % Cache Size 个元素生成初始的 mix，因为两个不同的 dataset 元素可能对应同一个Cache中的元素，为了保证每个初始的min都不同，注意到i也参与哈希计算。

​	随后循环 256次，每次根据当前 mix 值，求得下一个要访问的Cache元素的下标，用这个Cache元素和mix求得新的mix值。

​	最终返回mix的哈希值，得到第i个DAG中的元素。

​	多次调用这个函数，就可以得到完整的 DAG。

​	DAG初始化大小为1G，每隔 3W个块重新生成时增大初始大小的 1/128。

**mining puzzle：** 通过区块头、nonce以及DAG求出一个与target比较的值

​	先通过 Header 和 nonce 求出一个初始的 mix，然后进入64次循环，根据当前 mix 值求出要访问的DAG元素的下标，然后根据这个下标访问DAG中两个连续的值。

​	最后返回mix的哈希值，用来和target比较。

​	注意到轻节点是临时计算出用到的 dataset 元素（DAG中的每个位置元素都可以独立生成），而旷工是直接访问内存。



>  为什么挖矿要设计成只用块头信息？
>
> ​	轻节点只下载块头就能验证区块是否符合挖矿难度要求。	
>
> 
>
> 目前以太坊已经调整成权益证明。



# 难度调整算法

- 比特币 2016 个块调整难度，目标维持在10分钟一个块。

- 以太坊每个区块都有可能调整。

  - 出块时间15秒左右。

  

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4%E5%85%AC%E5%BC%8F.png" alt="难度调整公式" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4-2.png" alt="难度调整-2" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4-3.png" alt="难度调整-3" style="zoom:50%;" />



## 难度炸弹

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4-4.png" alt="难度调整-4" style="zoom:50%;" />

​	设计挖矿因为难度炸弹导致很难挖矿，可以方便切 PoS 协议。



## 相关代码

```go
func makeDifficultyCalculator(bombDelay *big.Int) func(time uint64, parent *types.Header) *big.Int {
	// Note, the calculations below looks at the parent number, which is 1 below
	// the block number. Thus we remove one from the delay given
	bombDelayFromParent := new(big.Int).Sub(bombDelay, big1)
	return func(time uint64, parent *types.Header) *big.Int {
		// https://github.com/ethereum/EIPs/issues/100.
		// algorithm:
		// diff = (parent_diff +
		//         (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))
		//        ) + 2^(periodCount - 2)

		bigTime := new(big.Int).SetUint64(time)
		bigParentTime := new(big.Int).SetUint64(parent.Time)

		// holds intermediate values to make the algo easier to read & audit
		x := new(big.Int)
		y := new(big.Int)

		// (2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9
		x.Sub(bigTime, bigParentTime)
		x.Div(x, big9)
		if parent.UncleHash == types.EmptyUncleHash {
			x.Sub(big1, x)
		} else {
			x.Sub(big2, x)
		}
		// max((2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9, -99)
		if x.Cmp(bigMinus99) < 0 {
			x.Set(bigMinus99)
		}
		// parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))
		y.Div(parent.Difficulty, params.DifficultyBoundDivisor)
		x.Mul(y, x)
		x.Add(parent.Difficulty, x)

		// minimum difficulty can ever be (before exponential factor)
		if x.Cmp(params.MinimumDifficulty) < 0 {
			x.Set(params.MinimumDifficulty)
		}
		// calculate a fake block number for the ice-age delay
		// Specification: https://eips.ethereum.org/EIPS/eip-1234
		fakeBlockNumber := new(big.Int)
		if parent.Number.Cmp(bombDelayFromParent) >= 0 {
			fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, bombDelayFromParent)
		}
		// for the exponential factor
		periodCount := fakeBlockNumber
		periodCount.Div(periodCount, expDiffPeriod)

		// the exponential factor, commonly referred to as "the bomb"
		// diff = diff + 2^(periodCount - 2)
		if periodCount.Cmp(big1) > 0 {
			y.Sub(periodCount, big2)
			y.Exp(big2, y, nil)
			x.Add(x, y)
		}
		return x
	}
}
```



# 权益证明(Proof of Stake)



> 思考：
>
> 1. 矿工为什么挖矿？为了收益
> 2. 为什么要给矿工收益？为了激励矿工参与区块链维护
> 3. 矿工怎么挖矿？需要资金买挖矿设备
> 4. 挖矿的收益由什么决定？资金决定收益
> 5. 直接比拼资金，权益证明思想（virtual mining）



- 优点
  - 节省能源
  - 工作量证明比拼的是资金，刚发布的数字货币资产与现实资产相比，占比很小，很容易被人用现实资金攻击（买大量矿机）。
    - 权益证明使用币投票，需要先获得半数以上的币，可以避免链外界的攻击



> **PoW和PoS可以是混合模型**
>
> ​	这种模式，仍然需要挖矿，但是挖矿的难度和持有的币相关。
>
> ​	持有币越多，挖矿难度越小。这样会造成拥有币最多的人，每次挖矿都是最容易。每次挖矿投入的币需要锁定一段时间，不能重复使用。被称为 proof of deposit。



## PoS 的问题

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/nothing%20at%20stake%20.png" alt="nothing at stake " style="zoom:50%;" />

​	早期权益证明可以在出现分叉的时候，进行两边下注，PoW不会，因为PoW只会选一个节点挖矿。



## Casper FFG

​	以太坊 PoS 协议：Casper the Friendly Finality Gadget（FFG）

​	单纯基于工作量证明的挖矿，是有可能会被回滚的。比特币规定要等6个确认区块，只能说6个确认区块后，回滚可能性非常小。

​	

​	引入验证者（ Validator ）概念。

​	成为 Validator 需要投入一定数量的保证金，保证金会被锁住。

​	Validator 作用：职责是推动系统达成共识，投票选择哪个是最长合法链。投票权重取决于保证金数量。

​	要成为 Validator 需要经历2轮 epoch 投票（每50个区块一个epoch）。

​	<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-02/casper.png" alt="casper" style="zoom:50%;" />

​	 对于前一个是 commit ，对于后一个是 prepare 投票。

​	连续两个 epoch 有 2/3 ，才能通过。



> 思考：
>
> ​	Casper 是否安全，Finality 是否会被推翻？
>
> ​	包含在 Finality 中的交易不会被推翻，仅仅是矿工是无法推翻的，因为 Validator 是投票选出来的。
>
> ​	什么情况能攻击成功？
>
> ​	一定是 Validator 两边下注，至少 1/3 Validator 两边下注。



# 智能合约

​	智能合约是运行在区块链上的一段代码。

​	合约运行状态：

* balance：当前余额
* nonce：交易次数
* code：合约代码
* storage：存储，数据结构是一个MPT



## Solidity 语言

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/Solidity.png" alt="Solidity" style="zoom:50%;" />

​	

- map 不支持遍历，必须用数组记录key。
- 接受转账的函数，必须声明 `payable`
- 



> **外部账户如何调用智能合约？**
>
> ​	创建一个交易，接受地址为要调用的智能合约的地址，data 域填写要调用的函数及其参数的编码值。



### 合约调用合约

* 直接调用

  * <img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8.png" alt="直接调用" style="zoom:50%;" />
  * 直接调用的方式（B调用A），A异常，B也会异常。

* 使用 address 类型 的  `call()` 函数

  * <img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/call%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png" alt="call函数调用" style="zoom:50%;" />

  * 地址`call()`的方式，会返回调用结果（true或False）

* 代理调用 `delegatecall()`

  * <img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E4%BB%A3%E7%90%86%E8%B0%83%E7%94%A8.png" alt="代理调用" style="zoom:50%;" />

  * 也会返回true或False，但是不能使用被调用方的上下文，用于库代码调用。

### fallback() 函数

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/fallback%E5%87%BD%E6%95%B0.png" alt="fallback函数" style="zoom:50%;" />

* 没有参数和返回值
* 如果合约需要有接受转账的能力，需要添加 `payable`。
* 只有合约账户才有



### 智能合约创建和运行

1. 智能合约的代码写完后，要编译成 bytecode
2. 创建合约：外部账户发起一个转账交易到 0x0 的地址
   1. 转账的金额是0，但是要支付 gas fee
   2. 合约的代码放在 data 域
3. 智能合约运行在 EVM 上
4. 以太坊是一个交易驱动的状态机
   1. 调用智能合约的交易发布到区块链上后，每个矿工都会执行这个交易，从当前状态确定性地转移到下一个状态



### 汽油费（gas fee）



<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E6%B1%BD%E6%B2%B9%E8%B4%B9.png" alt="汽油费" style="zoom:50%;" />

​	死循环是 停机问题（Halting Problem），不可解。

​	将问题推给调用方，通过 gas fee 控制执行。



### 错误处理

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.png" alt="错误处理" style="zoom:50%;" />

* assert
* require
* revert



### 嵌套调用

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8.png" alt="嵌套调用" style="zoom:50%;" />



### 智能合约可以获得的信息

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E5%8C%BA%E5%9D%97%E4%BF%A1%E6%81%AF.png" alt="智能合约可以获得区块信息" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E7%9A%84%E8%B0%83%E7%94%A8%E4%BF%A1%E6%81%AF.png" alt="智能合约可以获得的调用信息" style="zoom:50%;" />

> 举例：
>
>  	A 调用 C1，C1又调用C2。A 是调用者。

### 地址类型

<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B.png" alt="地址类型" style="zoom:50%;" />

* addr.balance：addr 的值的余额
* addr.transfer(12345)：向 addr 转入 12345



## 控制区块大小



- 比特币是通过 1M 的块大小判断。
- 以太坊是当前区块可以消耗的 gas 的上限（block 中的 GasLimit 字段）。
  - 矿工可以上、下调 1/1024 ，最终是全网矿工的平均值



## Receipt 数据结构

> 问题：交易中有对智能合约的调用，全节点是先挖矿还是先执行智能合约？
>
> ​	全节点本地维护了3个树（状态、交易、收集树），先执行智能合约，修改本地数据结构，计算出3个根哈希值，才能用随机数挖矿。
>
> ​	挖到矿的节点才有收益（GHOST协议），其他都是陪太子读书（挖矿慢的更吃亏）。
>
> 
>
> 问题：执行失败的交易是否要发布？
>
> ​	执行错误的交易，也要发布，因为要扣除 gas 费用。



<img src="https://cdn.jsdelivr.net/gh/ColinWeng/oss@main/uPic/2025-09-03/receipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="receipt数据结构" style="zoom:50%;" />

- status ： 交易结果状态。





> 参考资料：
>
> 1. https://www.bilibili.com/video/av37065233?vd_source=9be1685e6d4edc7dc5e4b37362c797e5&spm_id_from=333.788.videopod.episodes
